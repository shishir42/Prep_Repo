https://www.youtube.com/@SwiftfulThinking/playlists

Sure, here's a list of some popular architecture patterns for mobile app development:
	1	Model-View-Controller (MVC)
	2	Model-View-ViewModel (MVVM)
	3	Model-View-Presenter (MVP)
	4	Clean Architecture
	5	Reactive Architecture
	6	Domain-Driven Design (DDD)
	7	Event-Driven Architecture (EDA)
	8	Layered Architecture
	9	Hexagonal Architecture (Ports and Adapters)
	10	MVPVM (Model-View-Presenter-View-Model)

iOS:

https://www.linkedin.com/feed/update/urn:li:activity:7037373753634283520/?updateEntityUrn=urn%3Ali%3Afs_feedUpdate%3A%28V2%2Curn%3Ali%3Aactivity%3A7037373753634283520%29

https://www.youtube.com/watch?v=oAPWduCv_xc&list=PLWZIhpNhtvfqBd00bF3ouroGHMPe-iroO&index=1

https://www.youtube.com/watch?v=wL2OvT82tjM&list=PLtCBuHKmdxOd9kxsru5t_MFvDj5o5GdDl&index=16
https://www.youtube.com/watch?v=Zu7E2VL2xa0&list=PLtCBuHKmdxOcmrDx2pM4qNvzWF2NI_Qlo&index=1

Swift
https://www.youtube.com/watch?v=sAvs0itMqi0&list=PLtCBuHKmdxOd9kxsru5t_MFvDj5o5GdDl
https://www.youtube.com/watch?v=bjPENR6sHRU&list=PL5PR3UyfTWvfacnfUsvNcxIiKIgidNRoW

Multiple Inheritance:
https://mobikul.com/multiple-inheritance-in-swift/
https://www.vadimbulavin.com/multiple-inheritance-swift/

Projects:
https://www.youtube.com/watch?v=Bu6fAlltatA
https://www.youtube.com/watch?v=b8sP7AS0CAY
https://www.youtube.com/watch?v=EJQW864XpmA
https://www.youtube.com/watch?v=KCgYDCKqato&t=1426s
https://www.youtube.com/@SwiftfulThinking/playlists

https://bambuser.com/docs/video-platform/broadcasting/ios-swift/
https://medium.com/javarevisited/my-favorite-ios-app-project-ideas-for-beginners-a873e7e6f88a
https://www.youtube.com/watch?v=1AXyC24NCkE
https://www.youtube.com/watch?v=aP-SQXTtWhY
https://www.youtube.com/watch?v=TcGn	O5VSJlI
https://www.youtube.com/watch?v=u8UOmfYmpoE&list=PLuoeXyslFTuZRi4q4VT6lZKxYbr7so1Mr
https://www.youtube.com/watch?v=VGJBLlfSN-Y&list=PLuoeXyslFTuaZtX7xSYbWz3TR0Vpz39gK
https://www.youtube.com/watch?v=OvLxxV7X1Is&list=PLuoeXyslFTubw4NtepDCis5tTqK37zT3Q
https://www.youtube.com/watch?v=YwNFw_doBnw&list=PLuoeXyslFTuaIzW91CexqpWSmxOWztkkL
https://www.youtube.com/watch?v=ug6T-iFk5OY&list=PLuoeXyslFTuaYpVr3S9wG6PkIvYn_yHbg
https://www.youtube.com/watch?v=-B-bnQSQr90&list=PLuoeXyslFTuaX59K2KL-HK2NxbdWiz3Tm

https://www.hackingwithswift.com/interview-questions
https://www.softwaretestinghelp.com/swift-interview-questions/
https://www.interviewbit.com/swift-interview-questions/
https://www.codingem.com/swift-interview-questions/
https://www.toptal.com/swift/interview-questions
https://www.fullstack.cafe/blog/swift-interview-questions
https://www.devteam.space/hiring-interview-tips/swift-interview-questions-and-answers/
https://gist.github.com/acrookston/da0652bb6a5e9b11f2e79b7dc04e533b
https://github.com/onthecodepath/iOS-Interview-Questions
https://github.com/dashvlas/awesome-ios-interview/blob/master/Resources/English.md
https://github.com/niks290192/Interview-Preprations
https://github.com/alexpaul/iOS-Interview-Preparation
https://github.com/DenisLitvin/iOS-Interview
https://gist.github.com/funmia/8f33509d70448523e9652db1bcfcad2a
https://github.com/kodecocodes/ios-interview/tree/master/iOS%20Specific%20Questions

SwiftUI provides a powerful and intuitive way to create responsive layouts for iOS applications. Here are some tips on how to approach responsive layout in iOS using SwiftUI:
	1	Use VStack and HStack: VStack and HStack are two of the most useful layout components in SwiftUI. VStack arranges views vertically, while HStack arranges views horizontally. You can use these components to create a responsive layout that adapts to different screen sizes and orientations.
	2	Use Spacer: Spacer is another useful layout component in SwiftUI that allows you to create flexible spaces between views. You can use Spacer to adjust the spacing between views and create a more balanced layout.
	3	Use GeometryReader: GeometryReader is a layout component that provides you with information about the size and position of the parent view. You can use GeometryReader to create a layout that adapts to the available space, regardless of the screen size.
	4	Use @EnvironmentObject: @EnvironmentObject is a property wrapper that allows you to share data between views. You can use @EnvironmentObject to pass data between views and create a responsive layout that updates based on user input or other factors.
	5	Use Size Classes: Size Classes are a way of categorizing different screen sizes and orientations. You can use Size Classes to create layouts that adapt to different screen sizes and orientations, without having to manually adjust the layout for each individual device.
By using these tips and techniques, you can create a responsive layout in iOS using SwiftUI that adapts to different screen sizes and orientations, providing a consistent user experience across all devices.

	1	Using VStack and HStack:

struct ContentView: View {
    var body: some View {
        VStack {
            Text("Hello, World!")
            HStack {
                Text("Left column")
                Spacer()
                Text("Right column")
            }
        }
    }
}


In this example, we're using a VStack to stack the views vertically, and then a HStack to arrange the two text views horizontally. The Spacer component is used to create flexible space between the left and right columns.


2 Using Spacer:

struct ContentView: View {
    var body: some View {
        HStack {
            Text("Left column")
            Spacer()
            Text("Right column")
        }
    }
}

Here, we're simply using Spacer to create flexible space between the left and right columns.

3 Using GeometryReader:

struct ContentView: View {
    var body: some View {
        GeometryReader { geometry in
            VStack {
                Text("Hello, World!")
                    .frame(width: geometry.size.width * 0.9, height: 50)
                Text("This text view adapts to the available space.")
                    .frame(width: geometry.size.width * 0.9)
            }
        }
    }
}
In this example, we're using GeometryReader to get the size of the parent view, and then using that size to adjust the width and height of the text views.


4 Using @EnvironmentObject:

class UserData: ObservableObject {
    @Published var isDarkMode = false
}

struct ContentView: View {
    @EnvironmentObject var userData: UserData
    
    var body: some View {
        VStack {
            Toggle(isOn: $userData.isDarkMode) {
                Text("Dark mode")
            }
            .padding()
            .background(Color.gray)
            
            if userData.isDarkMode {
                Text("Hello, World!")
                    .foregroundColor(.white)
                    .background(Color.black)
            } else {
                Text("Hello, World!")
                    .foregroundColor(.black)
                    .background(Color.white)
            }
        }
    }
}

In this example, we're using @EnvironmentObject to pass data between views. The UserData class defines a isDarkMode variable that is used to toggle between light and dark mode. We're using this variable to adjust the text color and background color of the text view.


5 Using Size Classes:

struct ContentView: View {
    @Environment(\.horizontalSizeClass) var horizontalSizeClass
    
    var body: some View {
        if horizontalSizeClass == .compact {
            VStack {
                Text("Hello, World!")
                    .frame(height: 50)
                Text("This is a compact screen size.")
            }
        } else {
            HStack {
                Text("Hello, World!")
                    .frame(width: 200, height: 50)
                Text("This is a regular screen size.")
            }
        }
    }
}

In this example, we're using @Environment(\.horizontalSizeClass) to get the size class of the device. Depending on the size class, we're either using a VStack or HStack to adjust the layout of the text views.




To create reusable UI components in SwiftUI, you can follow these steps:
	1	Define a new SwiftUI view that encapsulates the desired UI component. For example, if you want to create a reusable button component, you can create a new view that represents that button.

struct CustomButton: View {
  var title: String
  var action: () -> Void
  
  var body: some View {
    Button(action: action) {
      Text(title)
        .foregroundColor(.white)
        .padding()
        .background(Color.blue)
        .cornerRadius(10)
    }
  }
}

In this example, the CustomButton view takes two parameters: the button's title and the action to perform when the button is tapped. The body property defines the visual representation of the button, including the button's text, background color, and corner radius.


	2	Use the new component in your SwiftUI code by creating an instance of the CustomButton view and passing in the necessary parameters.


struct ContentView: View {
  var body: some View {
    VStack {
      CustomButton(title: "Sign In") {
        // Perform sign in action
      }
      
      CustomButton(title: "Create Account") {
        // Perform create account action
      }
    }
  }
}

In this example, the ContentView view uses the CustomButton view to display two buttons: one for signing in and one for creating an account.
	3	(Optional) Customize the appearance and behavior of the component by adding additional parameters to the view's initializer.
For example, you can add a parameter for the button's font size or background color, and use those parameters to customize the visual appearance of the button.

struct CustomButton: View {
  var title: String
  var action: () -> Void
  var backgroundColor: Color = .blue
  var foregroundColor: Color = .white
  var cornerRadius: CGFloat = 10
  var fontSize: CGFloat = 16
  
  var body: some View {
    Button(action: action) {
      Text(title)
        .foregroundColor(foregroundColor)
        .font(.system(size: fontSize))
        .padding()
        .background(backgroundColor)
        .cornerRadius(cornerRadius)
    }
  }
}

In this updated version of the CustomButton view, several new parameters have been added, including backgroundColor, foregroundColor, cornerRadius, and fontSize. These parameters can be used to customize the appearance and behavior of the button when it is used in other parts of your SwiftUI code.
By following these steps, you can create reusable UI components in SwiftUI that can be used throughout your app.



There are many advanced topics in iOS development. Here are some of them:
	1	Core Data: A framework for managing and persisting data in iOS apps.
	2	Core Animation: A framework for creating complex animations and visual effects in iOS apps.
	3	Core Graphics: A framework for rendering 2D and 3D graphics in iOS apps.
	4	Core ML: A framework for integrating machine learning models into iOS apps.
	5	UIKit Dynamics: A physics engine for creating realistic animations and interactions in iOS apps.
	6	Metal: A low-level graphics API for creating high-performance 3D games and visualizations in iOS apps.
	7	SiriKit: A framework for integrating your app with Siri to allow users to interact with your app through voice commands.
	8	HealthKit: A framework for integrating your app with Apple's Health app to track health and fitness data.
	9	ARKit: A framework for creating augmented reality experiences in iOS apps.
	10	Core Bluetooth: A framework for integrating Bluetooth Low Energy (BLE) devices into iOS apps.
	11	Core Location: A framework for integrating location-based services into iOS apps.
	12	Push Notifications: A framework for sending notifications to iOS devices even when the app is not running.
	13	Core Motion: A framework for accessing the device's motion sensors (accelerometer, gyroscope, etc.) in iOS apps.
	14	Core Audio: A framework for recording, playing back, and manipulating audio in iOS apps.
	15	iCloud: A framework for syncing data between iOS devices and the cloud.

Bluetooth stack refers to the set of software components that enable Bluetooth communication between devices. The Bluetooth stack includes several layers, each responsible for different aspects of the communication process, from physical transmission to application-level interaction.
In iOS, the Bluetooth stack is implemented as a framework called Core Bluetooth. This framework provides a set of APIs that developers can use to interact with Bluetooth devices, both as central devices (that initiate connections) and peripheral devices (that accept connections).
To use Core Bluetooth to interact with a peripheral device, you'll need to follow these general steps:
	1	Discover the peripheral device: Use the CBCentralManager class to scan for nearby Bluetooth devices and discover the one you want to interact with. The peripheral device should advertise its presence using Bluetooth Low Energy (BLE) advertising packets.
	2	Connect to the peripheral device: Once you've discovered the peripheral device, you can use the connect(_:options:) method of CBCentralManager to establish a Bluetooth connection.
	3	Discover services and characteristics: After establishing a connection, you can use the discoverServices(_:) method of CBPeripheral to discover the available services on the peripheral device. Once you've discovered a service, you can use the discoverCharacteristics(_:for:) method to discover the available characteristics within that service.
	4	Interact with characteristics: Once you've discovered the characteristics you're interested in, you can use the readValue(for:), writeValue(_:for:type:), and setNotifyValue(_:for:) methods of CBPeripheral to read, write, and monitor changes to the characteristic values.
	5	Disconnect from the peripheral device: When you're finished interacting with the peripheral device, you should use the cancelPeripheralConnection(_:) method of CBCentralManager to disconnect from it.
Keep in mind that the specific steps and APIs you'll need to use will depend on the particular peripheral device and the requirements of your application. Additionally, you'll need to ensure that your iOS device has Bluetooth enabled and that your app has the necessary permissions to interact with Bluetooth devices.


To send and receive data using Bluetooth commands, you'll need to use the Bluetooth Low Energy (BLE) protocol, which is designed for low-power devices like wearable sensors, health monitors, and other types of Internet of Things (IoT) devices. BLE uses a client-server model, where the central device (such as a smartphone) acts as the client and the peripheral device (such as a sensor) acts as the server.
Here are the general steps to send and receive data using Bluetooth commands:
	1	Connect to the peripheral device: Use the Core Bluetooth framework to discover and connect to the peripheral device you want to communicate with.
	2	Discover the services and characteristics: Use the discoverServices(_:) and discoverCharacteristics(_:for:) methods of the CBPeripheral class to discover the available services and characteristics on the peripheral device.
	3	Write data to a characteristic: Use the writeValue(_:for:type:) method of the CBPeripheral class to write data to a specific characteristic on the peripheral device. The data you write should be in the form of a Data object.
	4	Read data from a characteristic: Use the readValue(for:) method of the CBPeripheral class to read data from a specific characteristic on the peripheral device. The data you read will be returned as a Data object.
	5	Receive data from a characteristic: Use the setNotifyValue(_:for:) method of the CBPeripheral class to set up a notification to receive data when a characteristic on the peripheral device is updated. You'll need to implement the peripheral(_:didUpdateValueFor:error:) method of the CBPeripheralDelegate protocol to handle the incoming data.
	6	Disconnect from the peripheral device: When you're finished communicating with the peripheral device, use the cancelPeripheralConnection(_:) method of the CBCentralManager class to disconnect from it.
Note that the specific commands and data formats you'll need to use will depend on the peripheral device you're communicating with and the requirements of your application. Make sure to consult the documentation for the peripheral device to determine the appropriate commands and data formats to use.


In SwiftUI, struct is used instead of class for views because struct instances are immutable, which makes them easier to reason about and safer to use in a multi-threaded environment.
Since SwiftUI heavily relies on state management and reactive programming, using mutable objects like classes could lead to unpredictable behavior. Structs, on the other hand, are value types and immutable by default, which means they can be copied safely and their state cannot be changed once created.
Furthermore, struct instances are also more performant than class instances, because they are allocated on the stack instead of the heap, reducing the overhead of memory allocation and deallocation.
In summary, using struct instead of class for SwiftUI views allows for safer and more performant code, which is essential for building modern, responsive and reliable iOS apps.



	1	What is SwiftUI and what are its benefits?
	2	What is the difference between SwiftUI and UIKit?
	3	What are the basic building blocks of SwiftUI?
	4	How do you create a new SwiftUI project in Xcode?
	5	What is the role of the @State property wrapper in SwiftUI?
	6	How do you pass data between views in SwiftUI?
	7	What is the difference between @State, @Binding, and @EnvironmentObject in SwiftUI?
	8	How do you create a custom view in SwiftUI?
	9	What is the difference between a view modifier and a view transformation in SwiftUI?
	10	How do you handle user input in SwiftUI?
	11	How do you add animations to a SwiftUI view?
	12	How do you integrate SwiftUI with Core Data?
	13	How do you use SwiftUI with networking?
	14	How do you handle errors in SwiftUI?
	15	How do you create a navigation view in SwiftUI?
	16	How do you create a tab view in SwiftUI?
	17	How do you create a list view in SwiftUI?
	18	What is the purpose of the @ObservedObject property wrapper in SwiftUI?
	19	How do you handle image assets in SwiftUI?
	20	How do you create a custom font in SwiftUI?
	21	How do you use localization in SwiftUI?
	22	What is the role of the @Environment property wrapper in SwiftUI?
	23	How do you use the preview canvas in SwiftUI?
	24	What is the difference between static and dynamic previews in SwiftUI?
	25	How do you debug a SwiftUI app?
	26	How do you test a SwiftUI app?
	27	What is the difference between a view and a scene in SwiftUI?
	28	How do you handle device orientation changes in SwiftUI?
	29	How do you use the safe area in SwiftUI?
	30	How do you use the accessibility features in SwiftUI?
	31	How do you implement dark mode in a SwiftUI app?
	32	How do you handle dynamic type in SwiftUI?
	33	How do you implement a search bar in a SwiftUI app?
	34	How do you create a custom navigation bar in SwiftUI?
	35	How do you create a custom tab bar in SwiftUI?
	36	What is the purpose of the @GestureState property wrapper in SwiftUI?
	37	How do you implement drag and drop in a SwiftUI app?
	38	How do you implement multi-touch gestures in a SwiftUI app?
	39	What is the role of the @FetchRequest property wrapper in SwiftUI?
	40	How do you use the Combine framework with SwiftUI?
	41	How do you implement push notifications in a SwiftUI app?
	42	How do you use the camera and photo library in a SwiftUI app?
	43	How do you implement authentication in a SwiftUI app?
	44	How do you implement in-app purchases in a SwiftUI app?
	45	How do you implement location services in a SwiftUI app?
	46	How do you use Firebase with SwiftUI?
	47	How do you use GraphQL with SwiftUI?
	48	What is the difference between a view model and a data model in SwiftUI?
	49	How do you use gestures in SwiftUI?
	50	How do you implement a custom transition animation in SwiftUI?


	1	Can you explain the difference between synchronous and asynchronous programming in iOS?
	2	What are the different types of memory management techniques in iOS?
	3	What is the use of ARC (Automatic Reference Counting) in iOS development?
	4	Can you explain the difference between retain and assign properties in iOS?
	5	Can you explain the concept of delegation in iOS?
	6	What are the different types of design patterns in iOS development?
	7	Can you explain the concept of MVC (Model-View-Controller) in iOS development?
	8	What is the use of protocols in iOS development?
	9	Can you explain the concept of blocks in iOS?
	10	How do you handle exceptions in iOS development?
	11	What are the different types of navigation controllers in iOS?
	12	Can you explain the use of Storyboards in iOS development?
	13	How do you handle background tasks in iOS development?
	14	Can you explain the use of Core Data in iOS development?
	15	What are the different types of testing frameworks in iOS development?
	16	Can you explain the use of push notifications in iOS development?
	17	How do you handle network calls in iOS development?
	18	Can you explain the use of URLSession in iOS development?
	19	How do you handle data persistence in iOS development?
	20	Can you explain the use of Keychain in iOS development?
	21	Can you explain the use of GCD (Grand Central Dispatch) in iOS development?
	22	What are the different types of animations in iOS development?
	23	How do you handle device orientation changes in iOS development?
	24	Can you explain the use of Core Graphics in iOS development?
	25	Can you explain the use of Core Animation in iOS development?
	26	Can you explain the use of MapKit in iOS development?
	27	How do you handle user input in iOS development?
	28	Can you explain the use of UIStackView in iOS development?
	29	Can you explain the use of Auto Layout in iOS development?
	30	What are the different types of table view cells in iOS development?
	31	How do you handle background fetch in iOS development?
	32	Can you explain the use of SwiftUI in iOS development?
	33	Can you explain the use of Combine framework in iOS development?
	34	How do you handle localization in iOS development?
	35	Can you explain the use of accessibility in iOS development?
	36	How do you handle debugging in iOS development?
	37	Can you explain the use of the AVFoundation framework in iOS development?
	38	Can you explain the use of the Core Image framework in iOS development?
	39	How do you handle push notifications with attachments in iOS development?
	40	Can you explain the use of the Core Location framework in iOS development?
	41	Can you explain the use of the Core Motion framework in iOS development?
	42	Can you explain the use of the Core ML framework in iOS development?
	43	How do you handle runtime exceptions in iOS development?
	44	Can you explain the use of Firebase in iOS development?
	45	How do you handle device battery life in iOS development?
	46	Can you explain the use of In-App Purchases in iOS development?
	47	How do you handle in-app browser links in iOS development?
	48	Can you explain the use of Core Bluetooth framework in iOS development?
	49	Can you explain the use of HealthKit in iOS development?
	50	How do you handle low memory situations in iOS development?


	1	What is UIKit?
	2	What is the difference between UIView and UIViewController?
	3	What is the difference between a frame and a bounds?
	4	What is the view hierarchy in iOS?
	5	What is the role of the UIApplicationDelegate?
	6	How do you create a custom UIView subclass?
	7	What is the difference between a UIView and a CALayer?
	8	What is the difference between a UIView and a UIWindow?
	9	What is the role of a UIStackView?
	10	What is Auto Layout?
	11	How do you add constraints in Auto Layout?
	12	What is the difference between intrinsic content size and content hugging priority?
	13	How do you animate a view in iOS?
	14	What is the difference between implicit and explicit animations?
	15	How do you handle user interactions in a view?
	16	What is the responder chain in iOS?
	17	How do you create custom animations?
	18	How do you create a custom transition between two view controllers?
	19	What is a collection view in iOS?
	20	How do you create a custom UICollectionViewCell?
	21	What is the difference between a UICollectionViewFlowLayout and a UICollectionViewDelegateFlowLayout?
	22	What is a table view in iOS?
	23	How do you create a custom UITableViewCell?
	24	What is the difference between UITableView and UICollectionView?
	25	How do you handle user input in a table view?
	26	How do you handle cell selection in a table view?
	27	What is the role of a UIActivityIndicatorView?
	28	What is the role of a UIPageControl?


	1	What is Objective-C and what is it used for?
	2	What are the differences between Objective-C and Swift?
	3	What are the basic data types in Objective-C?
	4	What is a property in Objective-C?
	5	What is a protocol in Objective-C?
	6	What is a category in Objective-C?
	7	What is a class method and an instance method in Objective-C?
	8	What is the difference between “copy” and “retain” in Objective-C?
	9	What is KVO (Key-Value Observing) in Objective-C?
	10	What is ARC (Automatic Reference Counting) in Objective-C?
	11	What is the difference between weak and strong reference in Objective-C?
	12	What is a block in Objective-C?
	13	How do you create a singleton in Objective-C?
	14	What is the difference between synchronous and asynchronous programming in Objective-C?
	15	How do you handle errors in Objective-C?
	16	What is the difference between NSNotification and delegation in Objective-C?
	17	What is the difference between an interface and an implementation in Objective-C?
	18	What is a nil pointer in Objective-C?
	19	What is the purpose of @synthesize in Objective-C?
	20	What is the purpose of @dynamic in Objective-C?
	21	How do you create a custom initializer in Objective-C?
	22	What is the difference between designated initializer and convenience initializer in Objective-C?
	23	What is a runtime in Objective-C?
	24	What is the purpose of the “respondsToSelector” method in Objective-C?
	25	What is the purpose of the “performSelector” method in Objective-C?
	26	What is the purpose of the “performSelectorInBackground” method in Objective-C?
	27	What is the purpose of the “performSelectorOnMainThread” method in Objective-C?
	28	What is the purpose of the “didReceiveMemoryWarning” method in Objective-C?
	29	What is the purpose of the “dealloc” method in Objective-C?
	30	What is the purpose of the “load” method in Objective-C?
	31	What is the purpose of the “initialize” method in Objective-C?
	32	What is the purpose of the “copyWithZone” method in Objective-C?
	33	What is the purpose of the “isEqual” method in Objective-C?
	34	What is the purpose of the “hash” method in Objective-C?
	35	What is the purpose of the “description” method in Objective-C?
	36	What is the purpose of the “mutableCopyWithZone” method in Objective-C?
	37	What is the purpose of the “NSCopying” protocol in Objective-C?
	38	What is the purpose of the “NSCoding” protocol in Objective-C?
	39	What is the difference between “retain” and “assign” in Objective-C?
	40	What is the difference between “strong” and “weak” in Objective-C?
	41	What is the difference between “nonatomic” and “atomic” in Objective-C?
	42	What is the purpose of the “autoreleasepool” in Objective-C?
	43	What is a dispatch queue in Objective-C?
	44	What is a GCD (Grand Central Dispatch) in Objective-C?
	45	What is a NSOperationQueue in Objective-C?
	46	What is a block-based enumeration in Objective-C?
	47	What is a NSPredicate in Objective-C?
	48	What is a NSNotificationCenter in Objective-C?
	49	What is a NSUserDefaults in Objective-C?
	50	What is a NSFileManager in Objective-C?


	1	What is the difference between a class and an object in Objective-C?
	2	Can you explain the concept of message passing in Objective-C?
	3	How does the use of protocols help in designing a flexible architecture in Objective-C?
	4	Can you explain the concept of memory management in Objective-C and how it is different from other programming languages?
	5	What are blocks in Objective-C and how are they used?
	6	How do categories and extensions differ in Objective-C?
	7	What is the difference between nonatomic and atomic properties in Objective-C?
	8	Can you explain the difference between a weak and a strong reference in Objective-C?
	9	How does Objective-C support multiple inheritance through the use of protocols?
	10	Can you explain the concept of Key-Value Coding (KVC) and Key-Value Observing (KVO) in Objective-C?
	11	How does Objective-C support concurrency through the use of Grand Central Dispatch (GCD) and Operation Queues?
	12	Can you explain the use of the @synthesize keyword in Objective-C?
	13	What is the difference between a class method and an instance method in Objective-C?
	14	How does Objective-C support introspection and reflection?
	15	Can you explain the use of the @dynamic keyword in Objective-C?
	16	What are some common design patterns used in Objective-C programming?
	17	Can you explain the difference between a delegate and a notification in Objective-C?
	18	How does Objective-C support error handling through the use of exceptions and error objects?
	19	What is the difference between an id type and a Class type in Objective-C?
	20	Can you explain the use of the copy and mutableCopy methods in Objective-C?


In SwiftUI, @State is a property wrapper that allows you to declare a property that can be mutated and that is also used to update the user interface. When the state value changes, SwiftUI automatically refreshes the view to reflect the updated value.
For example, suppose you have a view that displays a counter. You can use @State to declare a property that holds the current count value:
struct CounterView: View {
    @State var count = 0
    
    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increment") {
                count += 1
            }
        }
    }
}

In this example, the count property is declared as a state variable with an initial value of 0. The Text view displays the current value of count, and the Button increments the count when pressed.

When the button is pressed, the value of count changes, which triggers SwiftUI to update the view and display the new count value.
@State is just one of the many property wrappers available in SwiftUI that allow you to declare properties with special behavior.



Here is a list of commonly used property wrappers in SwiftUI:
	1	@State: A property wrapper that allows you to declare a mutable state variable that is used to update the user interface.
	2	@Binding: A property wrapper that allows you to create a two-way binding between a view and a value stored in another view.
	3	@ObservedObject: A property wrapper that allows you to declare a reference to an observable object that notifies SwiftUI when its properties change.
	4	@EnvironmentObject: A property wrapper that allows you to declare a reference to an object stored in the environment, which can be shared across multiple views.
	5	@GestureState: A property wrapper that allows you to declare a state variable that represents the current state of a gesture.
	6	@FetchRequest: A property wrapper that allows you to declare a fetch request that retrieves data from Core Data.
	7	@StateObject: A property wrapper that allows you to declare a reference to an observable object that is created and managed by the view.
	8	@ScaledMetric: A property wrapper that allows you to declare a metric value that automatically scales with the user's preferred font size.
	9	@ViewBuilder: A property wrapper that allows you to build a view hierarchy dynamically, based on a set of input parameters.

These property wrappers provide powerful and flexible ways to manage state, data, and user interactions in SwiftUI apps.

@State and @Binding are both property wrappers in SwiftUI that are used to manage state in a view. However, they have different use cases and behaviors.
@State is used to declare a mutable state variable that is owned and managed by the view. When the value of a @State variable changes, SwiftUI automatically updates the view to reflect the new value. @State variables are typically used to manage local state that is specific to a particular view.
On the other hand, @Binding is used to declare a two-way binding between a view and a value stored in another view or the view's parent. When the value of the bound property changes, both the view and the source of the binding are updated. @Binding variables are typically used to pass state between different views or to create reusable components.
Here is an example that illustrates the difference between @State and @Binding:
struct ContentView: View {
    @State private var isOn = false
    
    var body: some View {
        VStack {
            Text(isOn ? "On" : "Off")
            Toggle("Toggle", isOn: $isOn)
            ChildView(isOn: $isOn)
        }
    }
}

struct ChildView: View {
    @Binding var isOn: Bool
    
    var body: some View {
        Toggle("Toggle", isOn: $isOn)
    }
}


Topic:
1. Basic
2. Operator
3. String and Characters
4. Collection types
5. Control Flow
6. Function 
7. closure
8. Enumeration 
9. Structure and Classes 
10. Properties 
11. method
12. Subscripts 
13. Inheritance 
14. Initialization and Deinitialization
15. Optional Chaining
16. Error Handling 
17. Concurrency 
18. Type Casting 
19. Nested Type 
20. Extension 
21. Protocol
22. Generics
23. Opaque type 
24. Automatic Reference count 
25. Memory Safety 
26. Access control 
27. Advanced Operators




In this example, ContentView declares a @State variable isOn that controls the state of a Toggle. ContentView also passes isOn as a @Binding to ChildView. ChildView displays another Toggle that is bound to isOn.
When the Toggle in ContentView is toggled, the value of isOn changes, which triggers SwiftUI to update the view. When the Toggle in ChildView is toggled, the value of isOn also changes, which triggers both views to update. The two Toggles stay in sync because they are bound to the same @State variable via a @Binding.


In SwiftUI, memory management is handled by the Swift language itself and the underlying iOS or macOS system. SwiftUI uses automatic reference counting (ARC) to manage memory, which means that the system automatically keeps track of references to objects and deallocates them when they are no longer needed.
SwiftUI also provides some additional mechanisms for managing memory, such as the @State, @Binding, and @Environment property wrappers. These wrappers help manage state in a SwiftUI view by automatically updating the view when the state changes. They also ensure that any changes to the state are propagated correctly throughout the app.
To prevent memory leaks, it's important to avoid strong reference cycles, where two objects have a strong reference to each other and neither can be deallocated. SwiftUI provides the weak and unowned keywords to prevent these cycles.
In addition to these language-level mechanisms, there are also best practices for memory management in SwiftUI, such as minimizing the use of global variables and using lazy initialization to defer the creation of expensive objects until they are needed.
Overall, memory management in SwiftUI is largely handled automatically by the Swift language and the underlying system, but developers should still be aware of best practices and potential issues to ensure their app is as efficient and performant as possible.


There are several ways to implement animations in SwiftUI:
	1	Implicit animations: Implicit animations are the simplest way to create animations in SwiftUI. They are triggered automatically whenever a view's state changes. To use implicit animations, you simply need to wrap your view's state change in a withAnimation block.
	2	Explicit animations: Explicit animations give you more control over the animation's timing and duration. You can use the Animation struct to specify the animation's properties, such as duration, timing curve, and delay.
	3	Transitions: Transitions allow you to animate the insertion, removal, or modification of views in a container. You can use the transition modifier to specify the animation that should be used when a view is added, removed, or modified.
	4	Animatable modifiers: Animatable modifiers allow you to animate a view's properties directly, without having to create a separate animation object. To create an animatable modifier, you need to implement the AnimatableModifier protocol.
	5	Custom animations: If none of the built-in animation types meet your needs, you can create your own custom animations using Core Animation or other animation frameworks. SwiftUI provides a bridge to Core Animation through the UIViewRepresentable protocol, which allows you to embed UIKit views and controllers in a SwiftUI view hierarchy.
Overall, SwiftUI provides a powerful and flexible set of tools for creating animations, and it's easy to get started with basic animations using implicit animations. As you become more comfortable with SwiftUI, you can explore more advanced animation techniques like custom animations and transitions.


Managing state is a fundamental part of building apps in SwiftUI. Here are some ways to manage state in SwiftUI:
	1	@State property wrapper: The @State property wrapper is used to manage state within a view. When a value marked with @State changes, the view automatically updates to reflect the new value. You can use @State to manage simple values like booleans and strings.


struct MyView: View {
    @State var isToggled = false

    var body: some View {
        Toggle(isOn: $isToggled) {
            Text("Toggle Me")
        }
    }
}


	2	@Binding property wrapper: The @Binding property wrapper allows a view to modify a value that is owned by another view or the app's environment. You can use @Binding to pass values between views, allowing one view to update another.

struct ContentView: View {
    @State var isToggled = false

    var body: some View {
        MyView(isToggled: $isToggled)
    }
}

struct MyView: View {
    @Binding var isToggled: Bool

    var body: some View {
        Toggle(isOn: $isToggled) {
            Text("Toggle Me")
        }
    }
}


	3	@EnvironmentObject property wrapper: The @EnvironmentObject property wrapper allows a view to access an object that is shared across the entire app. You can use @EnvironmentObject to manage complex state across multiple views.

class MyModel: ObservableObject {
    @Published var isToggled = false
}

struct ContentView: View {
    @EnvironmentObject var myModel: MyModel

    var body: some View {
        MyView()
    }
}

struct MyView: View {
    @EnvironmentObject var myModel: MyModel

    var body: some View {
        Toggle(isOn: $myModel.isToggled) {
            Text("Toggle Me")
        }
    }
}

These are just a few examples of the ways you can manage state in SwiftUI. Other tools and techniques, such as @StateObject, @ObservedObject, and @Published, can also be used to manage state in more complex scenarios.


Yes, you can use state management frameworks like ObservableObject and @EnvironmentObject to manage the navigation stack and screen navigation in SwiftUI.
Here's an example of how to do this:
	1	Create an ObservableObject to manage the navigation state:

class NavigationManager: ObservableObject {
    @Published var currentScreen: String = "Home"
    @Published var navigationStack: [String] = ["Home"]

    func navigateTo(screen: String) {
        currentScreen = screen
        navigationStack.append(screen)
    }

    func navigateBack() {
        guard navigationStack.count > 1 else { return }
        navigationStack.removeLast()
        currentScreen = navigationStack.last ?? "Home"
    }

    func resetNavigation() {
        currentScreen = "Home"
        navigationStack = ["Home"]
    }
}


In this example, we define a NavigationManager class as an ObservableObject. We have a currentScreen property to store the current screen being displayed, and a navigationStack property to maintain the navigation history. We also define three methods - navigateTo, navigateBack, and resetNavigation - to handle screen navigation.
	2	Create an instance of NavigationManager and pass it as an @EnvironmentObject to your root view:


let navigationManager = NavigationManager()

@main
struct MySwiftUIApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(navigationManager)
        }
    }
}


In this example, we create an instance of NavigationManager and pass it as an @EnvironmentObject to our root view, ContentView.
	3	Use the NavigationManager to navigate between screens in your views:


struct ContentView: View {
    @EnvironmentObject var navigationManager: NavigationManager

    var body: some View {
        NavigationView {
            VStack {
                Text("This is the \(navigationManager.currentScreen) view")
                Button("Go to Second Screen") {
                    navigationManager.navigateTo(screen: "Second")
                }
            }
            .navigationBarTitle("Home")
        }
    }
}

struct SecondScreenView: View {
    @EnvironmentObject var navigationManager: NavigationManager

    var body: some View {
        VStack {
            Text("This is the Second Screen")
            Button("Go Back") {
                navigationManager.navigateBack()
            }
        }
        .navigationBarTitle("Second Screen")
    }
}


In this example, we use the NavigationManager to navigate between the ContentView and SecondScreenView. We inject the NavigationManager instance as an @EnvironmentObject in both views, and use its methods to navigate between screens. When the user taps the "Go to Second Screen" button, we call the navigateTo method to push the SecondScreenView onto the navigation stack. When the user taps the "Go Back" button in the SecondScreenView, we call the navigateBack method to pop the view off the navigation stack.
By using state management frameworks like ObservableObject and @EnvironmentObject, you can create a flexible and centralized navigation system for your SwiftUI app.


*******************************

Sure, here's an example of how to manage navigation between multiple screens using the NavigationManager approach I described earlier.
	1	Create an ObservableObject to manage the navigation state:

class NavigationManager: ObservableObject {
    @Published var currentScreen: String = "Home"
    @Published var navigationStack: [String] = ["Home"]

    func navigateTo(screen: String) {
        currentScreen = screen
        navigationStack.append(screen)
    }

    func navigateBack() {
        guard navigationStack.count > 1 else { return }
        navigationStack.removeLast()
        currentScreen = navigationStack.last ?? "Home"
    }

    func resetNavigation() {
        currentScreen = "Home"
        navigationStack = ["Home"]
    }
}


	2	Create an instance of NavigationManager and pass it as an @EnvironmentObject to your root view:

let navigationManager = NavigationManager()

@main
struct MySwiftUIApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(navigationManager)
        }
    }
}


	3	Create your views and use the NavigationManager to navigate between screens:


struct ContentView: View {
    @EnvironmentObject var navigationManager: NavigationManager

    var body: some View {
        NavigationView {
            VStack {
                Text("This is the \(navigationManager.currentScreen) view")
                Button("Go to Second Screen") {
                    navigationManager.navigateTo(screen: "Second")
                }
            }
            .navigationBarTitle("Home")
        }
    }
}

struct SecondScreenView: View {
    @EnvironmentObject var navigationManager: NavigationManager

    var body: some View {
        VStack {
            Text("This is the Second Screen")
            Button("Go to Third Screen") {
                navigationManager.navigateTo(screen: "Third")
            }
            Button("Go Back") {
                navigationManager.navigateBack()
            }
        }
        .navigationBarTitle("Second Screen")
    }
}

struct ThirdScreenView: View {
    @EnvironmentObject var navigationManager: NavigationManager

    var body: some View {
        VStack {
            Text("This is the Third Screen")
            Button("Go to Fourth Screen") {
                navigationManager.navigateTo(screen: "Fourth")
            }
            Button("Go Back") {
                navigationManager.navigateBack()
            }
        }
        .navigationBarTitle("Third Screen")
    }
}

struct FourthScreenView: View {
    @EnvironmentObject var navigationManager: NavigationManager

    var body: some View {
        VStack {
            Text("This is the Fourth Screen")
            Button("Go to Fifth Screen") {
                navigationManager.navigateTo(screen: "Fifth")
            }
            Button("Go Back") {
                navigationManager.navigateBack()
            }
        }
        .navigationBarTitle("Fourth Screen")
    }
}

struct FifthScreenView: View {
    @EnvironmentObject var navigationManager: NavigationManager

    var body: some View {
        VStack {
            Text("This is the Fifth Screen")
            Button("Reset Navigation") {
                navigationManager.resetNavigation()
            }
            Button("Go Back") {
                navigationManager.navigateBack()
            }
        }
        .navigationBarTitle("Fifth Screen")
    }
}

Sure, you can create a NavigationManager to manage the state transition and use an observer pattern to notify the NavigationView when to navigate to a new screen.
Here's an example implementation of a NavigationManager:
class NavigationManager: ObservableObject {
    enum NavigationTarget {
        case none
        case screen1
        case screen2
        case screen3
        // add more screens as needed
    }
    
    @Published var navigationTarget: NavigationTarget = .none
}


This NavigationManager has an enum to represent the possible navigation targets (screens) and a @Published property navigationTarget to hold the current navigation target.
Now, let's modify the previous example to use the NavigationManager.
First, we need to inject the NavigationManager instance into the views that need to trigger the navigation. We can do this using the @EnvironmentObject property wrapper.

struct ContentView: View {
    @EnvironmentObject var navigationManager: NavigationManager
    
    var body: some View {
        NavigationView {
            VStack {
                Text("This is the Home view")
                Button("Go to Second Screen") {
                    navigationManager.navigationTarget = .screen1
                }
                Button("Go to Third Screen") {
                    navigationManager.navigationTarget = .screen2
                }
            }
            .navigationBarTitle("Home")
            .onReceive(navigationManager.$navigationTarget) { target in
                switch target {
                case .screen1:
                    NavigationLink(
                        destination: SecondScreenView(),
                        label: { EmptyView() }
                    )
                    .simultaneousGesture(TapGesture().onEnded{
                        self.navigationManager.navigationTarget = .none
                    })
                case .screen2:
                    NavigationLink(
                        destination: ThirdScreenView(),
                        label: { EmptyView() }
                    )
                    .simultaneousGesture(TapGesture().onEnded{
                        self.navigationManager.navigationTarget = .none
                    })
                case .none:
                    break
                }
            }
        }
    }
}

In this modified version of ContentView, we've injected the navigationManager instance using the @EnvironmentObject property wrapper.
We also added an .onReceive modifier to the VStack that listens to changes in the navigationManager.navigationTarget property. When the property changes, we create a NavigationLink to the appropriate destination screen, and attach a TapGesture to dismiss the NavigationLink after it has been navigated to. Finally, we set the navigationManager.navigationTarget property to .none to reset the state.
To make this work, we need to instantiate the NavigationManager and pass it down to the ContentView. We can do this in the SceneDelegate.swift file:

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?
    let navigationManager = NavigationManager()

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        let contentView = ContentView().environmentObject(navigationManager)

        // ...
    }

    // ...
}

With this implementation, you can now trigger navigation to different screens dynamically based on some logic, and have a NavigationManager to manage the state transition.



Scaling an iOS app involves making sure that the app can handle an increasing number of users, transactions, and data without experiencing any significant performance issues or downtime. Here are some approaches to scale an iOS app:
	1	Optimize app performance: One of the critical steps in scaling an iOS app is to optimize its performance. This involves optimizing the app's code, database queries, and network requests to make the app more responsive, efficient, and reliable.
	2	Use a Content Delivery Network (CDN): A CDN is a distributed network of servers that helps distribute app content to users quickly and efficiently. By using a CDN, app developers can reduce latency and improve user experience by caching static content like images, videos, and other multimedia files closer to the user.
	3	Use Cloud Services: Cloud services like Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure can help scale an iOS app by providing scalable and reliable infrastructure services like databases, storage, and computing power. By using cloud services, app developers can scale their apps' infrastructure on demand and pay only for the resources they use.
	4	Implement Load Balancing: Load balancing involves distributing incoming traffic across multiple servers to prevent any single server from being overloaded. By implementing load balancing, app developers can ensure that their app can handle a significant amount of traffic and transactions.
	5	Use Caching: Caching involves storing frequently accessed data in memory to reduce the number of database queries and network requests needed to retrieve data. By using caching, app developers can improve the app's performance and reduce the load on the app's infrastructure.
	6	Implement Horizontal Scaling: Horizontal scaling involves adding more instances of the app's infrastructure, such as servers or virtual machines, to handle an increasing number of users and transactions. By implementing horizontal scaling, app developers can ensure that their app can handle an increasing load without experiencing any significant performance issues or downtime.
	7	Monitor and analyze app performance: To scale an iOS app successfully, app developers need to monitor and analyze the app's performance continually. By using performance monitoring tools like New Relic, AppDynamics, or Datadog, app developers can identify performance bottlenecks and optimize their app's performance accordingly.


Sure, here are some approaches to scale an iOS app specifically:
	1	Optimize App Performance: As iOS devices have limited resources compared to desktops or servers, optimizing the app's performance is critical for scaling an iOS app. This involves optimizing the app's code, database queries, and network requests to make the app more responsive, efficient, and reliable.
	2	Use Apple's CDN: Apple provides a Content Delivery Network (CDN) called Apple CDN that distributes content to iOS devices. By using Apple CDN, app developers can reduce latency and improve user experience by caching static content like images, videos, and other multimedia files closer to the user.
	3	Use Apple's Cloud Services: Apple offers cloud services like iCloud and CloudKit that iOS app developers can use to store and sync user data across multiple devices. By using Apple's cloud services, app developers can scale their apps' infrastructure on demand and pay only for the resources they use.
	4	Implement App Thinning: App Thinning is an approach that allows developers to create iOS apps that are optimized for different devices and operating systems. By implementing app thinning, app developers can reduce the app's size and optimize the app's performance for each device, leading to better user experience and faster app performance.
	5	Use Caching: Caching involves storing frequently accessed data in memory to reduce the number of database queries and network requests needed to retrieve data. By using caching, iOS app developers can improve the app's performance and reduce the load on the app's infrastructure.
	6	Implement Horizontal Scaling: Horizontal scaling involves adding more instances of the app's infrastructure, such as servers or virtual machines, to handle an increasing number of users and transactions. By implementing horizontal scaling, iOS app developers can ensure that their app can handle an increasing load without experiencing any significant performance issues or downtime.
	7	Monitor and Analyze App Performance: To scale an iOS app successfully, iOS app developers need to monitor and analyze the app's performance continually. By using performance monitoring tools like Firebase or Instabug, app developers can identify performance bottlenecks and optimize their app's performance accordingly.


Optimizing database queries and network requests is a critical step in making an iOS app more responsive, efficient, and reliable. Here are some strategies that iOS app developers can use to optimize their app's database queries and network requests:
	1	Use indexes: Indexes can help speed up database queries by creating a searchable index of a column or group of columns in a table. By using indexes, app developers can reduce the amount of time it takes to search for data, leading to faster database queries and improved app performance.
	2	Minimize the number of database queries: App developers should try to minimize the number of database queries their app makes by grouping queries together or caching frequently accessed data in memory. By reducing the number of database queries, app developers can improve their app's performance and reduce the load on the database server.
	3	Use asynchronous programming: Asynchronous programming allows app developers to execute database queries and network requests in the background without blocking the app's user interface. By using asynchronous programming, app developers can improve the app's responsiveness and reduce the likelihood of the app crashing due to long-running database queries or network requests.
	4	Use efficient network protocols: App developers should use efficient network protocols like HTTP/2 or WebSockets to reduce the amount of data sent over the network and improve the app's performance. By using efficient network protocols, app developers can reduce the app's network latency and improve the app's overall performance.
	5	Optimize database schema: App developers should optimize their database schema to improve database performance. This involves using appropriate data types, normalizing tables, and creating appropriate relationships between tables. By optimizing the database schema, app developers can improve the app's database performance and reduce the likelihood of database errors.
	6	Use server-side caching: App developers can use server-side caching to store frequently accessed data in memory on the server, reducing the need for database queries and improving app performance. By using server-side caching, app developers can also reduce the app's network latency and improve the app's overall performance.
	7	Monitor database and network performance: App developers should continuously monitor their app's database and network performance to identify bottlenecks and optimize performance accordingly. By monitoring performance, app developers can identify slow database queries, network latency issues, or other performance bottlenecks and take appropriate action to optimize performance.

Implementing caching in iOS can significantly improve app performance and reduce network requests. Here are some approaches to implementing caching in an iOS app:
	1	Use NSCache: NSCache is a class in iOS that provides an in-memory cache for objects. App developers can use NSCache to cache frequently accessed data, such as images or API responses. NSCache is straightforward to use and provides automatic memory management, making it a popular choice for iOS app developers.
	2	Use NSURLCache: NSURLCache is another caching mechanism in iOS that caches HTTP and HTTPS responses. App developers can configure the NSURLCache to cache responses for a certain amount of time or a maximum size. NSURLCache is beneficial when dealing with web requests and API responses.
	3	Use a third-party caching library: There are several third-party caching libraries available for iOS, such as SDWebImage and Kingfisher. These libraries provide an easy-to-use API for caching images and other data, making it simple for app developers to add caching functionality to their app.
	4	Use Core Data: Core Data is a framework in iOS that provides data persistence for an app's data model. App developers can use Core Data to cache frequently accessed data, reducing the need for database queries and improving app performance. Core Data is beneficial when dealing with complex data models and relationships.
	5	Use a custom caching solution: App developers can also implement a custom caching solution in their app. A custom caching solution can be tailored to the specific needs of the app and can provide advanced caching features such as expiration policies, in-memory caching, or disk caching.
Regardless of the caching approach, app developers should keep in mind that caching can cause issues like stale data or excessive memory usage if not used correctly. App developers should also monitor their app's caching behavior and adjust their caching strategy if necessary.

Implementing caching in Swift for iOS involves selecting the appropriate caching mechanism and integrating it into the app. Here are some general steps to implement caching in a Swift iOS app:
	1	Determine what data to cache: App developers should identify which data is suitable for caching, such as images or API responses, and which data should not be cached.
	2	Select a caching mechanism: There are several caching mechanisms available for Swift iOS app development, such as NSCache, NSURLCache, Core Data, or third-party libraries like SDWebImage or Kingfisher. Choose a caching mechanism based on the app's needs and the data to be cached.
	3	Integrate caching mechanism into the app: After selecting a caching mechanism, integrate it into the app's codebase. For example, if using NSCache, create an instance of the NSCache class, add data to the cache, and retrieve data from the cache when needed. For NSURLCache, configure the cache settings and use URLSession to make requests that use the cache.
	4	Set caching policies: App developers should set caching policies for the cached data, such as the expiration time or maximum cache size. This ensures that cached data is valid and not taking up too much memory.
	5	Monitor caching behavior: After implementing caching, app developers should monitor its behavior to ensure it is working as expected. This may include monitoring the cache hit rate, the size of the cache, or the frequency of cache evictions.
Here is an example of how to implement caching using NSCache in Swift:
// Create an instance of NSCache
let cache = NSCache<NSString, UIImage>()

// Add data to the cache
cache.setObject(image, forKey: cacheKey)

// Retrieve data from the cache
if let cachedImage = cache.object(forKey: cacheKey) {
  // Use the cached image
} else {
  // Fetch the image from the network
}

// Set caching policies
cache.countLimit = 100 // Set maximum number of objects in cache
cache.totalCostLimit = 10 * 1024 * 1024 // Set maximum cache size to 10MB

// Monitor caching behavior
let cacheHitRate = Double(cache.hitCount) / Double(cache.hitCount + cache.missCount)
print("Cache hit rate: \(cacheHitRate)")



you can create a custom caching solution using URLSession and Core Data or NSCache to cache images. The basic approach would be:
	1	Make a network request to fetch the image data.
	2	Cache the image data in Core Data or NSCache.
	3	Display the cached image data in the UI.

Here's an example implementation using Core Data:


import SwiftUI
import CoreData

struct ContentView: View {
    @Environment(\.managedObjectContext) var moc
    
    var body: some View {
        VStack {
            Text("Hello, world!")
            ImageView(urlString: "https://example.com/image.jpg")
                .frame(width: 200, height: 200)
        }
    }
}

struct ImageView: View {
    @ObservedObject var imageLoader: ImageLoader
    
    init(urlString: String) {
        self.imageLoader = ImageLoader(urlString: urlString)
    }
    
    var body: some View {
        Image(uiImage: UIImage(data: imageLoader.imageData) ?? UIImage(systemName: "photo")!)
            .resizable()
    }
}

class ImageLoader: ObservableObject {
    @Published var imageData = Data()
    var urlString: String
    
    init(urlString: String) {
        self.urlString = urlString
        loadImage()
    }
    
    func loadImage() {
        // Check if image is in cache
        if let cachedImageData = CacheManager.shared.getImageData(forKey: urlString) {
            imageData = cachedImageData
            return
        }
        
        // Make network request
        guard let url = URL(string: urlString) else { return }
        URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else { return }
            DispatchQueue.main.async {
                self.imageData = data
            }
            
            // Cache image data
            CacheManager.shared.saveImageData(data, forKey: urlString)
        }.resume()
    }
}

class CacheManager {
    static let shared = CacheManager()
    
    private let cache = NSCache<NSString, NSData>()
    
    func saveImageData(_ data: Data, forKey key: String) {
        cache.setObject(data as NSData, forKey: key as NSString)
    }
    
    func getImageData(forKey key: String) -> Data? {
        return cache.object(forKey: key as NSString)
	}

func clearCache() {
        cache.removeAllObjects()
    }
}	


The clearCache() method allows you to clear the cache if needed. You can adjust the cache size and other settings using the NSCache initializer or its properties. This implementation stores the image data in memory, but you can also save it to disk if you need to persist the cache between app launches.

In iOS, thread-safe operations are important to ensure that different parts of your app can safely access and modify shared resources, such as global variables, arrays, or objects. Swift provides several ways to implement thread-safe operations:

1. Using locks: Swift provides NSLock and NSRecursiveLock classes, which can be used to lock and unlock sections of code. For example, to make an array thread-safe, you can use NSLock to lock the array before accessing it and unlock it after you are done. Here's an example:

let lock = NSLock()
var array = [Int]()

func addElement(_ element: Int) {
    lock.lock()
    defer {
        lock.unlock()
    }
    array.append(element)
}

In this example, addElement uses lock.lock() to acquire the lock and prevent other threads from accessing the array. The defer statement ensures that the lock is always unlocked, even if an error occurs or the function returns early.

2. Using GCD (Grand Central Dispatch): GCD is a low-level API provided by iOS to manage concurrency. It provides a set of functions and APIs to execute tasks concurrently and synchronize access to shared resources. Here's an example of using GCD to make an array thread-safe:

let queue = DispatchQueue(label: "com.example.myqueue", attributes: .concurrent)
var array = [Int]()

func addElement(_ element: Int) {
    queue.async(flags: .barrier) {
        array.append(element)
    }
}

In this example, queue is a concurrent queue that is created with the .concurrent attribute. The addElement function uses queue.async(flags: .barrier) to ensure that the write operation is executed atomically and other threads are blocked until the write operation is complete.

3. Using atomic properties: Atomic properties are thread-safe by default in Swift. Atomic properties are accessed using a getter and a setter, which ensures that only one thread can access the property at a time. Here's an example:

class MyClass {
    private var _myProperty: Int = 0
    var myProperty: Int {
        get {
            return _myProperty
        }
        set {
            objc_sync_enter(self)
            _myProperty = newValue
            objc_sync_exit(self)
        }
    }
}

In this example, myProperty is an atomic property that is accessed using a getter and a setter. The objc_sync_enter and objc_sync_exit functions are used to ensure that the setter is thread-safe.



Here are 20 Swift programming interview questions that you might encounter:
	1	What is Swift, and how is it different from Objective-C?
	2	What is the difference between a value type and a reference type in Swift?
	3	What are optionals in Swift, and how do you handle them?
	4	What is a guard statement, and how is it used in Swift?
	5	What is a closure in Swift, and how is it used?
	6	What is a protocol in Swift, and how is it used?
	7	What is the difference between a class and a struct in Swift?
	8	What is ARC (Automatic Reference Counting) in Swift, and how does it work?
	9	What is the difference between synchronous and asynchronous code in Swift?
	10	What is the difference between a function and a method in Swift?
	11	What is a generic type in Swift, and how is it used?
	12	What is the difference between a computed property and a stored property in Swift?
	13	What is the difference between an extension and a protocol in Swift?
	14	What is a delegate in Swift, and how is it used?
	15	What is the difference between a map and a filter in Swift?
	16	What is a lazy property in Swift, and how is it used?
	17	What is a tuple in Swift, and how is it used?
	18	What is a guard-let statement, and how is it used?
	19	What is the difference between a didSet and a willSet observer in Swift?
	20	What is a switch statement in Swift, and how is it used?

	1	What is the difference between a closure and a function in Swift?
	2	What is the difference between a type and a protocol in Swift, and how do they relate to each other?
	3	How do you handle errors in Swift, and what is the difference between a try, a try?, and a try!?
	4	What is protocol-oriented programming, and how does it relate to object-oriented programming in Swift?
	5	What is type erasure, and how is it used in Swift?
	6	How do you implement dependency injection in Swift, and what are the benefits of using it?
	7	What is the difference between a property wrapper and a custom getter/setter in Swift?
	8	What is the difference between a raw value and an associated value in an enum in Swift?
	9	How do you handle concurrency in Swift, and what are some common patterns for doing so?
	10	What is the difference between a class cluster and a regular class in Swift?
	11	What is the difference between an instance method and a class method in Swift, and how do you implement them?
	12	What is a closure capture list in Swift, and how is it used?
	13	What is the difference between a lazy variable and a computed variable in Swift, and when would you use each one?
	14	What is the difference between a generic protocol and an associated type in Swift?
	15	What is a variadic parameter in Swift, and how is it used?
	16	What is a recursive function in Swift, and how do you implement it?
	17	What is the difference between a mutating method and a non-mutating method in Swift, and how do you use them?
	18	What is a type alias in Swift, and how is it used?
	19	What is the difference between a didSet and a willSet observer in Swift, and how do you use them?
	20	What is a trailing closure in Swift, and how is it used?


	1	What is the difference between a struct and a class in Swift, and when would you use one over the other?
	2	What is a closure capture list in Swift, and how is it used to prevent retain cycles?
	3	What is a type eraser in Swift, and how is it used to hide the underlying type of a generic value?
	4	What is a property wrapper in Swift, and how is it used to add additional behavior to properties?
	5	What is SwiftUI, and how does it differ from UIKit?
	6	What is a protocol-oriented programming (POP) in Swift, and how is it used to build flexible and extensible code?
	7	What is a key path in Swift, and how is it used to access and modify properties of an object?
	8	What is a result type in Swift, and how is it used to handle errors and asynchronous operations?
	9	What is a @escaping closure in Swift, and how is it used to capture and use a closure after the function returns?
	10	What is a typealias in Swift, and how is it used to provide a more descriptive name for a type?
	11	What is a guard statement in Swift, and how is it used to handle errors and unexpected conditions?
	12	What is a where clause in Swift, and how is it used to filter and transform collections?
	13	What is a generic function in Swift, and how is it used to write flexible and reusable code?
	14	What is a lazy sequence in Swift, and how is it used to defer the computation of a sequence until it is needed?
	15	What is a value type and a reference type in Swift, and how do they differ in terms of memory management and mutability?
	16	What is a type-safe builder pattern in Swift, and how is it used to build complex objects using a fluent API?
	17	What is a Swift package manager, and how is it used to manage dependencies and build projects?
	18	What is a higher-order function in Swift, and how is it used to write functional-style code?
	19	What is a SwiftLint, and how is it used to enforce code style and best practices in Swift projects?
	20	What is a Swift playground, and how is it used to experiment and explore Swift code?

	1	What is protocol-oriented programming, and how does it differ from object-oriented programming?
	2	What are higher-order functions, and how are they used in Swift?
	3	What is type erasure, and how is it used in Swift?
	4	What is a key path in Swift, and how is it used?
	5	What are property wrappers, and how are they used in Swift?
	6	What is the difference between a function and a closure in Swift?
	7	What is a variadic function, and how is it used in Swift?
	8	What is a recursive function, and how is it used in Swift?
	9	What is the difference between an infix, prefix, and postfix operator in Swift?
	10	What is the difference between a static and a class method in Swift?
	11	What is a computed property observer in Swift, and how is it used?
	12	What is a lazy sequence in Swift, and how is it used?
	13	What is the difference between a class and a protocol in Swift, and when would you use each one?
	14	What is a closure capture list in Swift, and how is it used?
	15	What is a type alias in Swift, and how is it used?
	16	What is the difference between a reference and a value type when working with closures in Swift?
	17	What is a function builder, and how is it used in Swift?
	18	What is the difference between an enumeration and a struct in Swift, and when would you use each one?
	19	What is a function signature, and how does it affect function overloading in Swift?
	20	What is a variadic parameter in Swift, and how is it used in functions and methods?
	
	1	What is protocol-oriented programming, and how is it different from object-oriented programming?
	2	What is a closure capture list, and how is it used?
	3	What is an escaping closure, and how is it used?
	4	What is the difference between a weak and an unowned reference in Swift?
	5	What is a generic where clause, and how is it used?
	6	What is a type erasure, and how is it used?
	7	What is a function builder, and how is it used in SwiftUI?
	8	What is the difference between a class and a AnyObject type in Swift?
	9	What is a recursive closure, and how is it used?
	10	What is a higher-order function, and how is it used in Swift?
	11	What is a mutating function, and when is it used?
	12	What is a lazy sequence, and how is it used?
	13	What is the difference between a struct and a class in Swift, in terms of memory management and performance?
	14	What is a key path, and how is it used?
	15	What is a result type, and how is it used in error handling?
	16	What is a property wrapper, and how is it used?
	17	What is a diffable data source, and how is it used in UITableView and UICollectionView?
	18	What is a variadic parameter, and how is it used?
	19	What is a compiler directive, and how is it used in Swift?
	20	What is the difference between an operator and a function in Swift?

Here are 20 interview questions on SwiftUI:
	1	What is SwiftUI, and how is it different from UIKit?
	2	What is a View in SwiftUI, and how is it different from a UIView?
	3	What is a State in SwiftUI, and how is it used?
	4	What is a Binding in SwiftUI, and how is it used?
	5	What is the difference between @State and @Binding in SwiftUI?
	6	What is a ObservableObject in SwiftUI, and how is it used?
	7	What is the difference between a @StateObject and a @ObservedObject in SwiftUI?
	8	What is the difference between a VStack and an HStack in SwiftUI?
	9	What is a modifier in SwiftUI, and how is it used?
	10	What is a gesture in SwiftUI, and how is it used?
	11	What is a navigation view in SwiftUI, and how is it used?
	12	What is the difference between a List and a ForEach in SwiftUI?
	13	What is a conditional statement in SwiftUI, and how is it used?
	14	What is a preference key in SwiftUI, and how is it used?
	15	What is a shape in SwiftUI, and how is it used?
	16	What is a coordinator in SwiftUI, and how is it used?
	17	What is an environment object in SwiftUI, and how is it used?
	18	What is a view modifier, and how is it used in SwiftUI?
	19	What is the difference between a ZStack and a VStack in SwiftUI?
	20	What is a view builder, and how is it used in SwiftUI?

	1	What is SwiftUI, and how is it different from UIKit?
	2	What is the purpose of the @State property wrapper in SwiftUI?
	3	What is the difference between @State and @Binding in SwiftUI?
	4	What is a View in SwiftUI, and how is it used?
	5	What is the difference between a struct and a class in SwiftUI, and when should each be used?
	6	What is a layout priority in SwiftUI, and how is it used?
	7	What is the purpose of the GeometryReader in SwiftUI, and how is it used?
	8	What is the purpose of the .onAppear and .onDisappear modifiers in SwiftUI, and how are they used?
	9	What is a Gesture in SwiftUI, and how is it used?
	10	What is a NavigationView in SwiftUI, and how is it used?
	11	What is a TabView in SwiftUI, and how is it used?
	12	What is the purpose of the @EnvironmentObject property wrapper in SwiftUI, and how is it used?
	13	What is a List in SwiftUI, and how is it used?
	14	What is the purpose of the .navigationBarTitle modifier in SwiftUI, and how is it used?
	15	What is the purpose of the .sheet modifier in SwiftUI, and how is it used?
	16	What is the purpose of the .alert modifier in SwiftUI, and how is it used?
	17	What is a custom modifier in SwiftUI, and how is it created?
	18	What is the purpose of the .frame modifier in SwiftUI, and how is it used?
	19	What is a TextField in SwiftUI, and how is it used?
	20	What is a Picker in SwiftUI, and how is it used?

	1	What is the purpose of the @FetchRequest property wrapper in SwiftUI, and how is it used with Core Data?
	2	What is the difference between a ViewModifier and a custom View in SwiftUI, and how are they created?
	3	What is the purpose of the @Environment property wrapper in SwiftUI, and how is it used?
	4	What is the purpose of the @Binding property wrapper in SwiftUI, and how is it used?
	5	What is a dynamic view in SwiftUI, and how is it created?
	6	What is the difference between the @ObservedObject and @StateObject property wrappers in SwiftUI, and when should each be used?
	7	What is the purpose of the .transition and .animation modifiers in SwiftUI, and how are they used?
	8	What is the purpose of the .background and .overlay modifiers in SwiftUI, and how are they used?
	9	What is the purpose of the @FetchRequestResult property wrapper in SwiftUI, and how is it used with Core Data?
	10	What is a container view in SwiftUI, and how is it created?
	11	What is the purpose of the @FetchRequestFetchRequestResult property wrapper in SwiftUI, and how is it used with Core Data?
	12	What is a preference key in SwiftUI, and how is it used?
	13	What is the purpose of the .onPreferenceChange modifier in SwiftUI, and how is it used?
	14	What is the purpose of the .navigationBarItems modifier in SwiftUI, and how is it used?
	15	What is the purpose of the .backgroundPreferenceValue modifier in SwiftUI, and how is it used?
	16	What is a focus state in SwiftUI, and how is it used?
	17	What is the purpose of the .disabled modifier in SwiftUI, and how is it used?
	18	What is the purpose of the .allowsHitTesting modifier in SwiftUI, and how is it used?
	19	What is a transaction in SwiftUI, and how is it used?
	20	What is the purpose of the .foregroundColor modifier in SwiftUI, and how is it used?

	1	What is the purpose of the @FetchRequest property wrapper in SwiftUI, and how is it used?
	2	What is the difference between a ViewModifier and a custom modifier in SwiftUI, and when should each be used?
	3	What is the purpose of the @Environment and @EnvironmentObject property wrappers in SwiftUI, and how are they used?
	4	What is the difference between a StateObject and an ObservedObject in SwiftUI, and when should each be used?
	5	What is a @DynamicProperty in SwiftUI, and how is it used?
	6	What is the purpose of the @GestureState property wrapper in SwiftUI, and how is it used?
	7	What is the purpose of the @ScaledMetric property wrapper in SwiftUI, and how is it used?
	8	What is the purpose of the .transition modifier in SwiftUI, and how is it used?
	9	What is a PreferenceKey in SwiftUI, and how is it used?
	10	What is the purpose of the .toolbar modifier in SwiftUI, and how is it used?
	11	What is the purpose of the .onChange modifier in SwiftUI, and how is it used?
	12	What is a Binding in SwiftUI, and how is it used?
	13	What is the purpose of the @FocusState property wrapper in SwiftUI, and how is it used?
	14	What is the purpose of the .accessibility modifier in SwiftUI, and how is it used?
	15	What is a GestureMask in SwiftUI, and how is it used?
	16	What is the purpose of the @ViewBuilder attribute in SwiftUI, and how is it used?
	17	What is the purpose of the .id modifier in SwiftUI, and how is it used?


In SwiftUI, a property wrapper is a type that allows you to add additional functionality to a property by wrapping it in another type. Here is a list of some of the most commonly used property wrappers in SwiftUI:
	1	@State: This property wrapper allows you to declare a stateful property in a SwiftUI view. Any changes to this property will cause the view to redraw.
	2	@Binding: This property wrapper allows you to create a two-way connection between a property in a parent view and a child view. When the child view updates the property, the parent view is notified of the change.
	3	@ObservedObject: This property wrapper allows you to declare a property that should be observed for changes. If the observed object changes, the view is redrawn.
	4	@Environment: This property wrapper allows you to access values that are set globally for the app or view hierarchy, such as the locale or the color scheme.
	5	@FetchRequest: This property wrapper allows you to declare a fetch request to Core Data that will be executed when the view is loaded.
	6	@StateObject: This property wrapper allows you to declare a stateful object that is owned by the view. Any changes to the object will cause the view to redraw.
	7	@GestureState: This property wrapper allows you to declare a stateful property that tracks the current state of a gesture. The property updates as the gesture progresses.
	8	@ScaledMetric: This property wrapper allows you to scale a value based on the user's preferred font size.
	9	@ViewBuilder: This property wrapper allows you to build a view hierarchy using a block of code instead of a function.
	10	@FocusState: This property wrapper allows you to manage the focus state of a view, such as a text field.

In SwiftUI, both @StateObject and @ObservedObject are property wrappers used to manage the state of a view. However, they are used in different ways and for different purposes.
@StateObject is used to manage the state of an object that is owned by the view itself. This means that the view creates and owns the object, and it's responsible for updating its state. The @StateObject property wrapper is used to declare a property that holds the object, and it's initialized when the view is created. The object is recreated automatically when the view is recreated.
On the other hand, @ObservedObject is used to manage the state of an object that is owned by another object. This means that the view observes the state of the object, but it doesn't own it. The @ObservedObject property wrapper is used to declare a property that holds the observed object, and it's initialized with an existing object. The object is not recreated automatically, and it's the responsibility of the parent object to update its state.
In summary, @StateObject is used to manage the state of an object that is owned by the view, while @ObservedObject is used to observe the state of an object that is owned by another object.

In SwiftUI, @Published is a property wrapper that's used to publish changes to a property to its subscribers. It's commonly used in conjunction with the ObservableObject protocol to create a model that can be observed by views, allowing the views to update themselves automatically when the model changes.

When you mark a property with the @Published property wrapper, any changes to that property will trigger an event to be sent to all of its subscribers. Subscribers can then react to these changes and update themselves accordingly. This makes it easy to create reactive user interfaces in SwiftUI, where views automatically update themselves based on changes to the underlying data model.

Without the @Published property wrapper, it would be much more difficult to create reactive user interfaces in SwiftUI. You would need to manually handle property changes and send events to subscribers, which would be tedious and error-prone. By using @Published, you can simplify the code required to create reactive user interfaces and improve the overall reliability and maintainability of your code.
In summary, @Published is used in SwiftUI to create reactive user interfaces by publishing changes to a property to its subscribers, allowing views to update themselves automatically when the model changes.


https://fuckingswiftui.com/

https://blog.canopas.com/swiftui-mvvm-state-management-in-a-simple-way-61efc8929b2f
https://www.swiftbysundell.com/articles/swiftui-state-management-guide/
https://www.headway.io/blog/intro-to-swiftui-state-management-for-react-developers


Objective-C
https://www.fullstack.cafe/blog/objective-c-interview-questions
https://www.devopsschool.com/blog/top-50-objective-interview-questions-and-answers/
https://medium.com/@gauravtaywade/interview-questions-every-ios-developer-should-know-part-1-7742af7be1ad
https://medium.com/@gauravtaywade/50-interview-questions-every-ios-developer-should-know-part-2-7c200f84d168
https://career.guru99.com/top-25-objective-c-interview-questions/
https://www.educba.com/objective-c-interview-questions/
https://www.interviewbit.com/ios-interview-questions/
https://www.acte.in/objective-c-interview-questions-and-answers/
https://in.indeed.com/career-advice/interviewing/objective-c-interview-questions
https://www.hackingwithswift.com/interview-questions
https://chetan-aggarwal.medium.com/ios-interview-questions-part-4-uikit-a8b6c8fda042
https://intellipaat.com/blog/interview-question/ios-interview-questions/
https://www.iosiqa.com/search/label/UI
https://www.simplilearn.com/ios-interview-questions-article
https://ishtiz.com/interview/ios-interview-guide-for-uikit-swiftui-top-30-in-2023
https://www.edureka.co/blog/interview-questions/ios-interview-questions/
https://www.udemy.com/course/ios-swift-interview-questions-answers/?utm_source=adwords&utm_medium=udemyads&utm_campaign=LongTail_la.EN_cc.INDIA&utm_content=deal4584&utm_term=_._ag_77882236463_._ad_533220806573_._kw__._de_c_._dm__._pl__._ti_aud-1738475842996%3Adsa-1007766171312_._li_9062009_._pd__._&matchtype=&gclid=CjwKCAjw586hBhBrEiwAQYEnHUN4-FEuNtVKO-k01cY8DQ9H1nTdPtuKapP61rfVqY6w56bDIZxHWhoCDZAQAvD_BwE
https://www.fullstack.cafe/blog/ios-interview-questions
https://hackr.io/blog/ios-interview-questions-and-answers
https://www.temok.com/blog/ios-interview-questions/
https://www.shiksha.com/online-courses/articles/ios-interview-questions-answers/
https://www.naukri.com/blog/ios-interview-questions-and-answers/
https://www.toptal.com/ios/interview-questions
https://anywhere.epam.com/en/blog/senior-ios-developer-interview-questions
https://byby.dev/ios-interview-swiftui
https://www.devteam.space/hiring-interview-tips/ios-interview-questions-and-answers/
https://www.datatrained.com/post/ios-interview-questions/
https://blog.devgenius.io/ios-development-important-concepts-ios-interview-questions-8c429d520bc2
https://iosinterviewguide.com/ios-interview-questions-for-senior-developers-in-2020
https://ishtiz.com/swiftui/swiftui-interview-questions-and-answers-part-1
https://medium.com/mop-developers/swiftui-answering-the-big-questions-3e6756ec2347
https://climbtheladder.com/swiftui-interview-questions/
https://ishtiz.com/interview/top-swiftui-interview-questions-answers
https://hackr.io/blog/swift-interview-questions
https://www.knowledgehut.com/interview-questions/swift
https://github.com/mindash/iOS-structured-interview
https://www.youtube.com/watch?v=DYktN9ue1rw&list=RDLVDYktN9ue1rw&start_radio=1&rv=DYktN9ue1rw&t=8



Projects
https://www.youtube.com/watch?v=Jhf3CNs8I-I&list=PLwvDm4Vfkdpha5eVTjLM0eRlJ7-yDDwBk
https://www.youtube.com/@SwiftfulThinking/playlists
https://www.youtube.com/watch?v=m6EH-JlCLsQ&list=PLnQbggnVfvo2wIr4kV1h6208xk1pPf2F0&index=1
https://www.youtube.com/watch?v=OgYluh5sYBA&list=PLnQbggnVfvo2Yg-gY7m3-tpvz4kpY8XyA
https://www.youtube.com/watch?v=Bu6fAlltatA&t=16s
https://www.youtube.com/watch?v=EYX_yPHBhAc
https://www.youtube.com/watch?v=b8sP7AS0CAY&t=2s
https://www.youtube.com/watch?v=1AXyC24NCkE&t=3551s
https://www.youtube.com/watch?v=wLLDrx_q7Es&t=11s
https://www.youtube.com/@SwiftyPlace/playlists





