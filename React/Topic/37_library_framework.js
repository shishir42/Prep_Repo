// Library

// Definition:
// Libraries provide developers with predefined functions and classes to make their work easier and boost the development process.

// Inversion of Control:
// By using a library, you can control the flow of the application and call the library. 

// Collection:
// Generally, libraries are a collection of helper modules, objects, classes, functions, message templates, pre-written code, etc.

// Code Modification:
// Codes in libraries are geared toward a particular program or to solve a specific development problem. Therefore, developers must modify library code to meet their needs.

// Scope:
// It is possible to call a library out of context. You may use the library wherever you see fit in your code.

// Function:
// In the program linking and binding process, they play an important role.

// Complexity:
// Having a library means understanding the functionality of each method, and it isn’t easy to create complex interactions since you need to call many methods to get the desired results.

// Extensibility:
// Generally, libraries aren’t designed for extensibility; they are designed to accomplish a specific purpose.

// Replaceable:
// It is easy to replace a library with another library. For instance, if you do not like the jQuery date picker library, you can use another date picker like a bootstrap date picker or pick date.

// Performance:
// Less code is required to build libraries, which leads to faster loading times and better performance.	

// Usage:
// The purpose of libraries is to perform a defined and specific task. Eg: Image manipulation, network protocols, math operations, etc.	

// Existing Projects:
// You can integrate libraries seamlessly into existing projects to add functionality. 

// Benefits:
// Good code quality, reusability, and control, enhanced speed and performance of the program, etc.

// Examples:
// JQuery, React JS, etc.

// Framework

// Definition:
// Framework, on the other hand, is like the foundation upon which developers build applications for specific platforms. 

// Inversion of Control:
// In contrast, when you use a framework, the control is inverted, i.e., the framework controls the flow and calls your code.

// Collection:
// Frameworks consist of a lot of APIs, compilers, toolsets, support programs, libraries, etc.

// Code Modification:
// Despite the fact that frameworks generate new codes for developers. These codes cannot be altered or modified later. Unlike libraries, frameworks do not allow users to modify their pre-written codes, so you don’t have to worry about deleting or changing them.

// Scope:
// On the other hand, you can only call and use what belongs to a Framework within the same Framework. 

// Function:
// Using them, you can build and deploy applications in a standard way as the framework already provides code to perform common tasks and uses code provided by a developer for custom functionality.

// Complexity:
// Frameworks, on the other hand, embody the basic flow, and since plugins need to be added to code, it is easier to do the right modification.

// Extensibility:
// Frameworks provide general functionality. Because of this, they are built to be extensible, which allows developers to incorporate app-specific features without modifying the framework’s source code.

// Replaceable:
// Frameworks are difficult to replace. If, for instance, you were using AngularJS to build your product, you cannot simply swap it out for another framework. It requires rewriting the entire codebase.

//Performance:
// Developing a framework requires a lot of coding, which increases loading times and decreases performance.

//Usage: 
// Frameworks can be used for performing a wide range of tasks. Among these are Web application systems, plug-in managers, GUI systems, and so on.

// Existing Projects:
// Incorporating frameworks seamlessly into an existing project is impossible. Instead, frameworks should be used when starting a new project.

// Benefits:
// Faster programming, support from the community, great support for MVC (Model View Controller) pattern, etc.

// Example:
// Spring, NodeJS, AngularJS, Vue JS, etc.