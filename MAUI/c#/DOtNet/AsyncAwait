In C#, async and await are keywords that are used in asynchronous programming. Asynchronous programming allows for the execution of tasks concurrently, without blocking the main thread.

The async keyword is used to declare a method that performs an asynchronous operation. An async method returns a Task or Task<T> object, which represents the ongoing operation. The await keyword is used to asynchronously wait for the completion of a Task or Task<T> object, without blocking the main thread.

Here is an example of an async method that simulates a long-running operation:

async Task<int> LongRunningOperationAsync()
{
    // Simulate a long-running operation
    await Task.Delay(5000);

    // Return a result
    return 42;
}


In this example, the LongRunningOperationAsync method returns a Task<int> object, which represents the ongoing operation. The await Task.Delay(5000) statement simulates a long-running operation that takes 5 seconds to complete. The return 42 statement returns a result of type int.

Here is an example of how to call the LongRunningOperationAsync method and asynchronously wait for its completion:

async void CallLongRunningOperationAsync()
{
    // Call the LongRunningOperationAsync method
    Task<int> task = LongRunningOperationAsync();

    // Do some other work while the operation is running
    DoOtherWork();

    // Wait for the operation to complete
    int result = await task;

    // Use the result
    Console.WriteLine(result);
}


In this example, the CallLongRunningOperationAsync method calls the LongRunningOperationAsync method and stores the resulting Task<int> object in the task variable. The DoOtherWork method is called to simulate some other work that can be done while the LongRunningOperationAsync method is running. The await task statement waits for the LongRunningOperationAsync method to complete and retrieves the result. Finally, the result variable is printed to the console.

It's important to note that async and await do not make code run faster, but rather they allow for more efficient use of resources by enabling the execution of multiple tasks simultaneously.


******
What is the purpose of async/await keywords?

These keywords allow writing asynchronous non-blocking code in a synchronous fashion.

This feature is facilitated by the Task/Task<T> classes or ValueTask/ValueTask<T> structs. These types represent an abstraction around an operation that may execute asynchronously.

We use await keyword to materialize the task into resulting value. Methods that contain await must be marked with the async keyword.

******

What's the difference between asynchronous programming and multithreaded programming?

An asynchronous task does not necessarily represent execution on a separate thread. You can think of an asynchronous operation as just an aggregation of two events -- start and finish.

A good example of an asynchronous operation is reading a file from a hard drive. To read individual bytes of a file, operating system issues requests to the driver software, which in turn tells the drive to seek to a specific position by moving its mechanical head. The process of moving the head around is asynchronous, it's not an operation that runs on CPU, it's just a physical task you have to wait for completing. This is the type of "pure" async operation that can be represented with the async/await pattern.

That said, an asynchronous task may also represent some CPU-bound calculation happening on a separate thread, but this is an implementation detail. This is useful when you want to delegate execution to a different thread in order to not block the calling thread, while disguising it as an asynchronous operation. You can do that by calling Task.Run().

Overall, it's fair to say that every multithreaded execution can be represented as an asynchronous operation, but not every asynchronous operation necessarily employs additional threads.

******

How does it work?

public async Task DoAsync()
{
    Console.WriteLine("Before await");

    await Task.Delay(TimeSpan.FromSeconds(1));

    Console.WriteLine("Between awaits");

    await Task.Delay(TimeSpan.FromSeconds(1));

    Console.WriteLine("After await");
}

Functionally, this code works by printing "Before await" to the console, waiting 1 second, printing "Between awaits", waiting 1 second again, and then printing "After await".

Everything until the first await is executed synchronously just like it would in a normal method. That means "Before await" will be printed on the same context that called this method.

The next thing that happens is that we create and run a new task using a static helper method Task.Delay(). This is a simple task that does nothing and automatically turns into completed after a specified delay.

Upon reaching the await keyword, the runtime will return control back to the calling method, which may or may not await it. If it does await, the same happens again, returning control to the caller of that method in turn, until it reaches a method in the call stack that either does not await (usually event handlers on a message loop thread) or materializes the task synchronously (e.g. entry point in a console application).

Once the task completes (after 1 second), the execution is returned back to our method, which continues by printing "Between awaits". By default, the execution will continue on the same context as the one that started executing this method.

Then the story repeats again by running and waiting on a new task, finally printing "After await". After the last message, the execution is returned to the caller method (if it awaited on DoAsync) so that it can continue executing further.

**********

What happens if we execute an asynchronous method but don't await it?

Nothing special, the operation represented by the task will continue its lifetime normally, but the result won't be observed. The task object itself will eventually be reclaimed by garbage collector.

Note that we can also use .ContinueWith() to handle the result in a call-back fashion.

******
What happens if an exception is thrown within an asynchronous method?

If the method is awaited, the exception will instantly propagate to the calling method, then to the caller of that method, and so on, as long as the whole chain is awaited.

Otherwise, the exception will be considered unobserved, which can lead (in some versions of the framework) to the application crashing as soon as the task is disposed by the finalizer.

*******

Is it possible to make a lambda that executes asynchronously?

Yes.
var result = await new Func<Task>(async () => await Task.Delay(100));


******
What happens when a method returns a Task without awaiting it?

public Task WaitAsync() => SomeOtherMethodAsync();

In this case, if an exception is thrown within asynchronous part of SomeOtherMethodAsync(), the WaitAsync() method will not be listed in the stack trace.

If a method returns a Task without awaiting it, the Task will still execute asynchronously in the background, but the calling code will not wait for it to complete. This can lead to a number of issues, including:

Memory leaks: If the Task creates any resources (e.g. network connections, file handles, etc.), those resources may not be released until the Task completes. If the Task is not awaited, those resources may be kept alive indefinitely, leading to memory leaks.

Unhandled exceptions: If the Task throws an exception, and the exception is not caught and handled, it will be silently ignored. This can make it difficult to debug issues in your code.

Race conditions: If the calling code continues executing while the Task is still running, it may lead to race conditions where the state of your program is inconsistent.

Incomplete or incorrect results: If the Task is performing some operation that produces a result (e.g. downloading a file), and the calling code does not wait for the Task to complete, the result may be incomplete or incorrect.

******

Task type implements IDisposable, when are we supposed to dispose tasks?

The Dispose() method is not supposed to be invoked manually, a task will be disposed automatically when you await it or when it's reclaimed by the GC.

******

What is the purpose of ConfigureAwait()?

By default, after the awaited task is completed, the execution continues on the originally captured context, i.e. the same thread that invoked the method. You can override that behavior by specifying ConfigureAwait(false), indicating that the execution may continue on a different context.

It's generally recommended using ConfigureAwait(false) wherever possible as it can offer minor performance gain and help prevent deadlocks.

******

What is the difference between Task and ValueTask?

The main difference is that Task is a class while ValueTask is a struct. Latter was added to the BCL to alleviate unnecessary pressure on the garbage collector caused by asynchronous methods that often return synchronously (e.g. cached result). You can think of ValueTask as a discriminated union of Task or a synchronous result. Since recently, ValueTask can also represent a result signaled by ValueTaskSource.

*****

What are the main downsides of using asynchronous methods compared to synchronous methods?

Asynchronous methods can be harder to debug, especially because exceptions thrown from asynchronous methods have difficult to read stack traces. Also, running many asynchronous tasks in a tight loop can put pressure on the garbage collector.

******

What is the difference between Concurrency and Parallelism? Are they same as async programming?

The terms concurrency and parallelism are often used in relation to multithreaded programs. Concurrency and parallelism are two confusing concepts. Although they appear to be the same, concurrency, parallelism, and multithreading are not the same thing.

A Concurrency refers to how a single CPU can make progress on multiple tasks seemingly at the same time, Parallelism, on the other hand, is related to how an application can parallelize the execution of a single task - typically by splitting the task up into subtasks which can be completed in parallel.

Concurrency:

In Concurrency, multiple different threads are doing different things at the same time. So concurrency means doing multiple things at the same time but it does not specifically refer to the use of multiple threads. In concurrency when you execute multiple tasks on the single-core and the core switches context (time slicing) between tasks and serves them.

Concurrent collections in .NET are contained inside the System.Collections.Concurrent namespace and provide lock-free and thread-safe implementations of the collection classes. The ConcurrentDictionary class is contained inside the System.Collections.Concurrent namespace and represents a thread-safe dictionary.

Parallelism:

Parallelism means you execute multiple tasks on multiple cores parallelly. Parallel execution is when a computer has more than one CPU or CPU core and makes progress on more than one task simultaneously.

Parallelism is a subset of concurrency and concurrency enables parallelism. So Concurrency is a broader term and Parallelism is a subset of it. 

Concurrency is about Design while Parallelism is about Hardware. In order to achieve concurrency, we need to compose our application logic independently. So Parallelism broadly means achieving concurrency by distributing work across multiple CPUs. 

Parallel.For, Parallel.ForEach and Parallel.Invoke is available in the TPL for parallel programming in C#.

Concurrency and Parallelism: Both Concurrency and Parallelism can be used together in different combinations:

1. Concurrent but Not Parallel:  An application can be concurrent, but not parallel. This means that it makes progress on more than one task seemingly at the same time (concurrently), but the application makes context switches between making progress on each of the tasks until the tasks are completed.

2. Parallel but Not Concurrent: An application can also be parallel but not concurrent. This means that the application only works on a single task at a time, and this task is broken down into subtasks that can be processed in parallel if multiple cores are available. 

3. Neither Concurrent Nor Parallel: An application can also be neither concurrent nor parallel. This means that it works on only one task at a time, and the task is never broken down into subtasks for parallel execution. 

4. Concurrent and Parallel: Finally, an application can also be both concurrent and parallel at the same time. In simple parallel concurrent execution where an application starts up multiple threads which are then executed on multiple CPUs. It is also possible that the application works on multiple tasks concurrently, and it also breaks each task down into subtasks for parallel execution.

Async and Await:

Async programming gets mixed up with the other two i.e Concurrency and Parallelism likely because it has something to do with threads. Async describes how individual threads are used.

If you use the term "concurrency" in multithreading then it's not related to async/await at all. If concurrency means doing multiple things simultaneously then async/await supports concurrency by allowing a single thread to start one process and then do something else instead of waiting for the first process to finish.

C# has a language-level asynchronous programming model, which allows for easily writing asynchronous code. The core of async programming is the Task and Task<T> objects, which model asynchronous operations. They are supported by the async and await keywords. 

The await keyword is where the magic happens. It yields control to the caller of the method that performed await, and it ultimately allows a UI to be responsive or service to be elastic. 

Example:

Consider two tasks, T1 and T2, that have to be executed by an application. 

These two tasks are in concurrent execution if one is in an execution state while the other is waiting for its turn. As a result, one of the tasks completes ahead of the other. 
On the other hand, the two tasks are in parallel execution if both execute simultaneously. To achieve task parallelism, the program must run on a CPU with multiple cores.

In the synchronous method, if a method Foo() takes 20 seconds to complete then the thread used to call that method will do nothing for 20 seconds except wait. 

But if we execute the same method in an asynchronous method, that thread can do other things for 20 seconds. When the command is finished executing, that thread will pick up where the first thread left off. For that we use await keyword before that method call i.e await Foo().

*******

Features of  Async Programming:

Async code can be used for both I/O-bound and CPU-bound code, but differently for each scenario.
Async code uses Task<T> and Task, which are constructs used to model work being done in the background.
The async keyword turns a method into an async method, which allows you to use the await keyword in its body.
All the async methods need to have an await keyword in their body or they will never yield. However, if await is not used in the body of an async method, the C# compiler generates a warning, but the code compiles and runs as if it were a normal method.
When the await keyword is applied, it suspends the calling method and yields control back to its caller until the awaited task is complete. But await can only be used inside an async method.
An async void should only be used for event handlers because events do not have return types.

*******

What is a Task in C#? What is the difference between task and thread?

A task in C# is used to implement Task-based Asynchronous Programming and was introduced with the .NET Framework 4. Tasks in C# are basically used to make your application more responsive. 

The Task object is typically executed asynchronously on a thread pool rather than synchronously on the main thread of the application. A task scheduler is responsible for starting the Task and also responsible for managing it. By default, the Task scheduler uses threads from the thread pool to execute the Task.

The .NET framework provides Threading.Tasks class to let you create tasks and run them asynchronously. A task is an object that represents some work that should be done. The task can tell you if the work is completed and if the operation returns a result, the task gives you a result. A task can be used whenever you want to execute something in parallel. Asynchronous implementation is easy in a task, using’ async’ and ‘await’ keywords.

The Task class represents a single operation that does not return a value and that usually executes asynchronously. Task objects are one of the central components of the task-based asynchronous pattern first introduced in the .NET Framework 4. 

A task that does not return a value is represented by the System.Threading.Tasks.Task class. A task that returns a value is represented by the System.Threading.Tasks.Task<TResult> class, which inherits from Task.

Because the work performed by a Task object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the Status property, as well as the IsCanceled, IsCompleted, and IsFaulted properties, to determine the state of a task. Most commonly, a lambda expression is used to specify the work that the task is to perform.

A Thread Pool in C# is a collection of threads that can be used to perform a number of tasks in the background. Once a thread completes its task, then again it is sent to the thread pool, so that it can be reused. This reusability of threads avoids an application to create a number of threads which ultimately uses less memory consumption.

The Task Parallel Library (TPL) is based on the concept of a task, which represents an asynchronous operation. In some ways, a task resembles a thread or ThreadPool work item, but at a higher level of abstraction.  In general, the Task class will always represent a single operation and that operation will be executed asynchronously on a thread pool thread rather than synchronously on the main thread of the application.

Task taskA = new Task(PrintMessage);
taskA.Start();

Task provide more programmatic control than is possible with a thread or work item. Tasks provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.

Thread thread = new Thread(new ThreadStart(PrintMessage));  
thread.Start(); 


Task vs Thread:

1. The Thread class is used for creating and manipulating a thread while a Task represents some asynchronous operation and is part of the TPL, a set of APIs for running tasks asynchronously and in parallel.
2. The task can return a result but there is no direct mechanism to return the result from a thread. We need to use a callback delegate in the thread to get the result from a thread.
3. Task supports cancellation through the use of cancellation tokens. But Thread doesn't.
4. A task can have multiple processes happening at the same time. Threads can only have one task running at a time.
5. We can easily implement Asynchronous programming using ’async’ and ‘await’ keywords. While we need to create, run and manage thread explicitly.
6. A new Thread() is not dealing with Thread pool thread, whereas Task does use thread pool thread.
7. A Task is a higher-level concept than Thread. So the task is at a higher level of abstraction.

*******

What is synchronization and why it is important?

Synchronization in C# is a mechanism that makes sure only one process or thread accesses the critical section of the program. All the other threads have to wait until the critical section is free before they can enter it. 

Synchronization is a technique that allows only one thread to access the resource for a particular time. No other thread can interrupt until the assigned thread finishes its task.

In a multithreading program, threads are allowed to access any resource for the required execution time. Threads share resources and execute asynchronously. Accessing shared resources (data) is a critical task that sometimes may halt the system even causing deadlock sometimes. 

Why Synchronization?

Thread Synchronization deals with Deadlock, Starvation, Priority Inversion, and Busy Waiting.
Synchronization is used for achieving mutual exclusion i.e. only one process or thread accesses the critical section of the program.
Synchronization makes sure that no thread or process has an infinite waiting time.
In Synchronization, all the requests are granted in a specific order using synchronization.
Synchronization can be used for resource allocation as well. It makes sure that only one process or thread can use a resource at a time.
It may cause deadlock if synchronization does not handle properly.

Different Methods to manage Synchronization:

The .NET Framework provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction. There are multiple ways to manage synchronization in the .Net which can be divided into 4 categories:

Blocking Methods (Join, Sleep, Task.Wait)
Locking Constructs (Lock, Mutex)
Non-Blocking Synchronization
Signaling

********

What is the difference between Join and Lock synchronization?

Using Synchronization, you can synchronize access to resources in multithreaded applications. Both Join and Lock are thread synchronization mechanisms in C#.

Join: 

Join is a blocking method of synchronization. In thread synchronization, join is a blocking mechanism that pauses the calling thread. This is done till the thread whose join method was called has completed its execution.

It is similar to Sleep but it does not pause all threads. It pauses the calling thread until the thread whose join method is called has been completed. 

Thread t1 = new Thread(Func1);    
t1.Start();    
Thread t2 = new Thread(Func2);    
t2.Start();    
t1.Join();    
t2.Join(); 

Lock: 

Locking is also a synchronization mechanism. It limits the access to a resource in multiple threads. An exclusive locking mechanism is used for it. There are two main Locking mechanisms:
Lock
Mutex

The lock is a synchronization method that is used to lock in the current thread so that no other thread can interrupt the execution of the locked thread. After the thread execution is complete, it is unlocked.

It locks the critical section of code so that only one thread can execute the critical section of code at a time. If another thread tries to enter into a critical section of code then it is prevented and blocked and then it will wait until the object is released from the using thread.

public void Display()  
{ 
	lock (this)  
	{ 
		for (int i = 1; i <= 5; i++)  
		{ 
			Thread.Sleep(100);  
			Console.WriteLine("i = {0}", i);  
		} 
	} 
} 

Mutex:

Mutex stands for Mutual Exclusion. The Mutex type ensures blocks of code are executed only once at a time. It is basically used in a situation where resources have to be shared by multiple threads simultaneously.  The System.Threading.Mutex class grants exclusive access to a shared resource. 

*******
what is ConfigureAwait in task and why need to set false 
ConfigureAwait is a method that is used in .NET when working with tasks to control how the context is captured when the task completes. By default, when a task completes, it captures the context of the thread that it completed on and uses that context when the continuation is executed. This can cause problems in certain scenarios, such as deadlocks or thread starvation, because the continuation may need to execute on a different context.

When you set ConfigureAwait to false, you are telling the task not to capture the current context when it completes. This can be useful in scenarios where you want the continuation to execute on a different thread or in a different context than the one that the original task completed on.

For example, if you have a web application that needs to make a network call to an external service and then update the UI based on the results of that call, you may want to set ConfigureAwait to false to avoid blocking the UI thread while the network call is being made. By doing this, the continuation will be scheduled on a different thread, allowing the UI thread to continue processing other events.

In summary, you should set ConfigureAwait to false in scenarios where you want to avoid blocking the current context when the task completes and when you want to ensure that the continuation is executed on a different thread or in a different context.



When calling the ConfigureAwait method on a task in .NET, you have two options: ConfigureAwait(true) and ConfigureAwait(false).

The difference between them is how the task continuation will be executed when the task completes.

When you call ConfigureAwait(true), the continuation will be executed in the same synchronization context as the original task. This means that if the original task was running on a UI thread, for example, the continuation will also run on the same UI thread. Similarly, if the original task was running on a background thread, the continuation will run on a background thread.

On the other hand, when you call ConfigureAwait(false), the continuation will be executed on any available thread from the thread pool, without necessarily capturing the current synchronization context. This can be useful when you don't want to block the current thread, or when you don't care about the synchronization context.

To summarize, if you need to ensure that the continuation runs in the same context as the original task, you should use ConfigureAwait(true). If you want to release the current context and execute the continuation on any available thread, use ConfigureAwait(false). In general, it's a good practice to use ConfigureAwait(false) when you don't need the synchronization context, as this can improve performance and prevent deadlocks.

The primary use case for calling ConfigureAwait(true) on a task in .NET is when you need to ensure that the continuation of the task runs in the same synchronization context as the original task.

A synchronization context is a mechanism that allows for the execution of asynchronous code in a way that is synchronized with the user interface (UI) thread in graphical user interface (GUI) applications. The UI thread is responsible for rendering the user interface and processing user input, so it's important that long-running or blocking operations are not executed on this thread to avoid freezing the UI.

By default, when a task completes, the continuation is executed on the same synchronization context as the original task. This means that if the original task was running on the UI thread, the continuation will also run on the UI thread. This can be useful for updating the UI or interacting with other components that require synchronization with the UI thread.

In scenarios where you need to update the UI or interact with other components that require synchronization with the UI thread after completing an asynchronous operation, you should call ConfigureAwait(true) on the task to ensure that the continuation runs on the UI thread. This can help avoid deadlocks or other synchronization issues that can occur when executing code on multiple threads.

For example, if you're using an asynchronous method to retrieve data from a remote service and update a control on the UI, you would call ConfigureAwait(true) on the task to ensure that the continuation that updates the UI is executed on the UI thread. This ensures that the user interface is updated smoothly and without any delays.

In summary, calling ConfigureAwait(true) is useful when you need to ensure that the continuation of a task runs on the same synchronization context as the original task, which is typically the case when working with UI or other components that require synchronization with the main thread.

**********

What is the role of the async method in C#?

The async method in C# is used to define a method that can be executed asynchronously. An asynchronous method allows you to perform long-running tasks without blocking the main thread of execution. Instead, the method is executed in a separate thread or in a thread pool, allowing the main thread to continue executing other tasks while waiting for the async method to complete.

To define an async method, you need to add the async keyword to the method signature. You can then use the await keyword to call other asynchronous methods, which will be executed in parallel with the current method. The await keyword ensures that the current method is suspended until the awaited method completes, and then resumes execution.

Here's an example of how you can use an async method to download a file from a URL:

public async Task DownloadFileAsync(string url, string path)
{
    using (var client = new HttpClient())
    {
        var content = await client.GetStringAsync(url);
        File.WriteAllText(path, content);
    }
}

In this example, we define an async method called DownloadFileAsync that takes a URL and a file path as arguments. We create an instance of the HttpClient class to download the content from the URL asynchronously using the GetStringAsync method. We then write the content to a file using the File.WriteAllText method.

By using the async and await keywords, we can execute the long-running task of downloading the file asynchronously, without blocking the main thread of execution. This allows the main thread to continue executing other tasks while waiting for the file download to complete.

In summary, the async method in C# allows you to write code that can be executed asynchronously, which can help improve the performance and responsiveness of your application.

****

How would you cancel an Async operation in C#?

In C#, you can cancel an asynchronous operation by using a CancellationToken. A CancellationToken is an object that can be used to cancel an operation that is in progress.

Here's an example of how to cancel an asynchronous operation using a CancellationToken:

public async Task DownloadFileAsync(string url, string path, CancellationToken cancellationToken)
{
    using (var client = new HttpClient())
    {
        var request = new HttpRequestMessage(HttpMethod.Get, url);
        var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken);

        using (var stream = await response.Content.ReadAsStreamAsync())
        {
            using (var fileStream = File.Create(path))
            {
                await stream.CopyToAsync(fileStream, 81920, cancellationToken);
            }
        }
    }
}


In this example, we modify the previous example by adding a CancellationToken parameter to the DownloadFileAsync method. We use the SendAsync method of the HttpClient class to send an HTTP request, passing in the cancellationToken parameter. We then use the ReadAsStreamAsync method of the HttpContent class to get a stream that contains the content of the response.

We use the CopyToAsync method of the Stream class to copy the content of the response stream to a file stream, passing in the cancellationToken parameter. The CopyToAsync method will throw a TaskCanceledException if the cancellation token is cancelled while the method is running.

To cancel the operation, you can call the Cancel method of the CancellationTokenSource object that was used to create the CancellationToken.

Here's an example of how to use a CancellationTokenSource to cancel the operation:

var cts = new CancellationTokenSource();

var task = DownloadFileAsync("https://example.com/file.txt", "file.txt", cts.Token);

// Cancel the task after 10 seconds
cts.CancelAfter(TimeSpan.FromSeconds(10));

try
{
    await task;
}
catch (TaskCanceledException)
{
    Console.WriteLine("Download cancelled.");
}


In this example, we create a CancellationTokenSource object and use it to create a CancellationToken object that is passed to the DownloadFileAsync method. We start the operation by calling the method, and then we cancel the operation after 10 seconds by calling the CancelAfter method of the CancellationTokenSource. We then wait for the task to complete by calling the await keyword, and catch the TaskCanceledException if it is thrown.

By using a CancellationToken, you can easily cancel an asynchronous operation in C#, allowing you to gracefully handle interruptions to long-running tasks.

************

Explain how does Asynchronous tasks Async/Await work in .NET? 
Asynchronous programming in .NET allows developers to write code that doesn't block the calling thread while waiting for long-running operations such as I/O or database access to complete. The two main ways to achieve asynchronous programming in .NET are through asynchronous methods and the Async/Await keywords.

The Async/Await keywords were introduced in C# 5.0 and are now a standard part of the language. They allow developers to write asynchronous code that looks similar to synchronous code, making it easier to read and maintain. Here's how they work:

Marking a method as async: To create an asynchronous method, you need to mark it with the async keyword. This tells the compiler that the method contains asynchronous operations and should be treated as such.

Using the Await keyword: When calling a method that returns a Task or Task<T>, you can use the Await keyword to suspend the execution of the method until the task completes. While the task is running, the calling thread is free to do other work.

Returning a Task: If the method itself returns a Task or Task<T>, it can be marked as async and can be awaited by calling code. When the method completes, it returns a TaskCompletionSource<T>, which contains the result of the asynchronous operation.

Using async/await with parallelism: The async/await keywords can also be used with parallel programming constructs such as Parallel.ForEach and Task.WhenAll, allowing multiple asynchronous operations to be executed in parallel.

Overall, Async/Await in .NET provides a simple and powerful way to write asynchronous code that is easier to read and maintain than traditional callback-based approaches. By allowing the calling thread to continue executing other work while waiting for asynchronous operations to complete, Async/Await can help improve application responsiveness and scalability.

************

Why Are Async and Await used in C#?
If we have a program that requires methods to be run independently of the primary process, we need to use asynchronous programming. This allows us to run processes and, when needed, make them wait without blocking the rest of the program.

To do this, we use the Async keyword to create an asynchronous method and Await to run it without blocking our program.

************

What are Async and Await?

Async and Await keywords are used to create asynchronous methods in C.

Asynchronous programming means that the process runs independently of main or other processes.

Usage of Async and Await is as shown below:

public async Task<int> CalculateCount()
{
    await Task.Delay(1000);
    return 1;
}

public async Task myMethod()
{
    Task<int> count = CalculateCount();
    int result = await count;
}


- Async keyword is used for the method declaration.
- The count is of a task of type int which calls the method CalculateCount().
- Calculatecount() starts execution and calculates something.
- Independent work is done on my thread and then await count statement is reached.
- If the Calculatecount is not finished, myMethod will return to its calling method, thus the main thread doesn’t get blocked.
- If the Calculatecount is already finished, then we have the result available when the control reaches await count. So the next step will continue in the same thread. However, it is not the situation in the above case where the Delay of 1 second is involved.

************
Explain the difference between Task and Thread in .NET
In simple terms, a task is something you want to get done, and a thread is a way to accomplish it. So in this sense, a thread is a part of the task.

A thread represents the smallest unit of code processing at the OS level, with stacks and kernels. You can exercise a high degree of control over threads with Suspend() or Abort() or Resume() a thread. ThreadPool, as the name suggests is a wrapper comprising a pool of threads maintained in the runtime environment by CLR.

A task in comparison is executed by a TaskScheduler and cannot create its own OS threads. A default scheduler runs on the ThreadPool and also lets you know when the task finishes and returns a result.

In .NET, Task and Thread are both used for multithreading and concurrency, but they have some key differences.

Abstraction level: Thread is a low-level construct that directly maps to an operating system thread, while Task is a higher-level abstraction that represents an asynchronous operation.

Creation and management: Creating and managing threads is more involved than creating and managing tasks. With Thread, you need to manually create and start the thread, and manage things like thread safety and synchronization. With Task, you create a delegate that represents the asynchronous operation, and then use the Task.Run or Task.Factory.StartNew methods to start the task.

Performance: Because Thread is a low-level construct, it can be more performant in certain scenarios where you need fine-grained control over the scheduling and synchronization of threads. Task, on the other hand, provides a higher-level abstraction that can simplify asynchronous programming, but may have some overhead due to the additional abstraction layer.

Error handling: With Thread, you need to manually handle exceptions that are thrown within the thread. With Task, any exceptions that are thrown within the task are propagated up the call stack to the code that awaits the task.

Resource usage: Creating and managing threads can be resource-intensive, as each thread requires memory for its stack and other overhead. Task can be more efficient in terms of resource usage, as the .NET runtime can manage the scheduling and reuse of threads behind the scenes.

************************************************************************************************************************
Task.Run and Task.Factory.StartNew are both methods for starting a new Task in .NET, but they have some differences in their behavior and usage.

Task.Run is a static method introduced in .NET 4.5, and is designed to simplify the creation and execution of a Task that runs a single asynchronous operation. It is typically used to start a new Task that will execute a delegate representing an asynchronous operation. The main advantages of using Task.Run over Task.Factory.StartNew are:

Simplified syntax: Task.Run provides a simpler and more intuitive syntax for starting a new Task that runs an asynchronous operation.

Better performance: Task.Run is designed to optimize the creation and execution of a Task that runs an asynchronous operation, and may be more performant than Task.Factory.StartNew in some scenarios.

Task.Factory.StartNew, on the other hand, is a more general-purpose method for starting a new Task. It allows you to specify a delegate representing any kind of operation, synchronous or asynchronous, and provides a range of options for configuring the behavior of the new Task. The main advantages of using Task.Factory.StartNew over Task.Run are:

Flexibility: Task.Factory.StartNew allows you to specify any kind of operation, not just an asynchronous operation.

Fine-grained control: Task.Factory.StartNew provides a range of options for configuring the behavior of the new Task, such as specifying the TaskCreationOptions and TaskScheduler to use.

However, it's worth noting that Task.Factory.StartNew can be more complex to use than Task.Run, and may require more care and attention to ensure correct behavior. Additionally, in some scenarios, using Task.Factory.StartNew with certain options (such as TaskCreationOptions.LongRunning) can result in worse performance than using Task.Run.
