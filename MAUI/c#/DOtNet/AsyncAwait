In C#, async and await are keywords that are used in asynchronous programming. Asynchronous programming allows for the execution of tasks concurrently, without blocking the main thread.

The async keyword is used to declare a method that performs an asynchronous operation. An async method returns a Task or Task<T> object, which represents the ongoing operation. The await keyword is used to asynchronously wait for the completion of a Task or Task<T> object, without blocking the main thread.

Here is an example of an async method that simulates a long-running operation:

async Task<int> LongRunningOperationAsync()
{
    // Simulate a long-running operation
    await Task.Delay(5000);

    // Return a result
    return 42;
}


In this example, the LongRunningOperationAsync method returns a Task<int> object, which represents the ongoing operation. The await Task.Delay(5000) statement simulates a long-running operation that takes 5 seconds to complete. The return 42 statement returns a result of type int.

Here is an example of how to call the LongRunningOperationAsync method and asynchronously wait for its completion:

async void CallLongRunningOperationAsync()
{
    // Call the LongRunningOperationAsync method
    Task<int> task = LongRunningOperationAsync();

    // Do some other work while the operation is running
    DoOtherWork();

    // Wait for the operation to complete
    int result = await task;

    // Use the result
    Console.WriteLine(result);
}


In this example, the CallLongRunningOperationAsync method calls the LongRunningOperationAsync method and stores the resulting Task<int> object in the task variable. The DoOtherWork method is called to simulate some other work that can be done while the LongRunningOperationAsync method is running. The await task statement waits for the LongRunningOperationAsync method to complete and retrieves the result. Finally, the result variable is printed to the console.

It's important to note that async and await do not make code run faster, but rather they allow for more efficient use of resources by enabling the execution of multiple tasks simultaneously.


******
What is the purpose of async/await keywords?

These keywords allow writing asynchronous non-blocking code in a synchronous fashion.

This feature is facilitated by the Task/Task<T> classes or ValueTask/ValueTask<T> structs. These types represent an abstraction around an operation that may execute asynchronously.

We use await keyword to materialize the task into resulting value. Methods that contain await must be marked with the async keyword.

******

What's the difference between asynchronous programming and multithreaded programming?

An asynchronous task does not necessarily represent execution on a separate thread. You can think of an asynchronous operation as just an aggregation of two events -- start and finish.

A good example of an asynchronous operation is reading a file from a hard drive. To read individual bytes of a file, operating system issues requests to the driver software, which in turn tells the drive to seek to a specific position by moving its mechanical head. The process of moving the head around is asynchronous, it's not an operation that runs on CPU, it's just a physical task you have to wait for completing. This is the type of "pure" async operation that can be represented with the async/await pattern.

That said, an asynchronous task may also represent some CPU-bound calculation happening on a separate thread, but this is an implementation detail. This is useful when you want to delegate execution to a different thread in order to not block the calling thread, while disguising it as an asynchronous operation. You can do that by calling Task.Run().

Overall, it's fair to say that every multithreaded execution can be represented as an asynchronous operation, but not every asynchronous operation necessarily employs additional threads.

******

How does it work?

public async Task DoAsync()
{
    Console.WriteLine("Before await");

    await Task.Delay(TimeSpan.FromSeconds(1));

    Console.WriteLine("Between awaits");

    await Task.Delay(TimeSpan.FromSeconds(1));

    Console.WriteLine("After await");
}

Functionally, this code works by printing "Before await" to the console, waiting 1 second, printing "Between awaits", waiting 1 second again, and then printing "After await".

Everything until the first await is executed synchronously just like it would in a normal method. That means "Before await" will be printed on the same context that called this method.

The next thing that happens is that we create and run a new task using a static helper method Task.Delay(). This is a simple task that does nothing and automatically turns into completed after a specified delay.

Upon reaching the await keyword, the runtime will return control back to the calling method, which may or may not await it. If it does await, the same happens again, returning control to the caller of that method in turn, until it reaches a method in the call stack that either does not await (usually event handlers on a message loop thread) or materializes the task synchronously (e.g. entry point in a console application).

Once the task completes (after 1 second), the execution is returned back to our method, which continues by printing "Between awaits". By default, the execution will continue on the same context as the one that started executing this method.

Then the story repeats again by running and waiting on a new task, finally printing "After await". After the last message, the execution is returned to the caller method (if it awaited on DoAsync) so that it can continue executing further.

**********

What happens if we execute an asynchronous method but don't await it?

Nothing special, the operation represented by the task will continue its lifetime normally, but the result won't be observed. The task object itself will eventually be reclaimed by garbage collector.

Note that we can also use .ContinueWith() to handle the result in a call-back fashion.

******
What happens if an exception is thrown within an asynchronous method?

If the method is awaited, the exception will instantly propagate to the calling method, then to the caller of that method, and so on, as long as the whole chain is awaited.

Otherwise, the exception will be considered unobserved, which can lead (in some versions of the framework) to the application crashing as soon as the task is disposed by the finalizer.

*******

Is it possible to make a lambda that executes asynchronously?

Yes.
var result = await new Func<Task>(async () => await Task.Delay(100));


******
What happens when a method returns a Task without awaiting it?

public Task WaitAsync() => SomeOtherMethodAsync();

In this case, if an exception is thrown within asynchronous part of SomeOtherMethodAsync(), the WaitAsync() method will not be listed in the stack trace.

******

Task type implements IDisposable, when are we supposed to dispose tasks?

The Dispose() method is not supposed to be invoked manually, a task will be disposed automatically when you await it or when it's reclaimed by the GC.

******

What is the purpose of ConfigureAwait()?

By default, after the awaited task is completed, the execution continues on the originally captured context, i.e. the same thread that invoked the method. You can override that behavior by specifying ConfigureAwait(false), indicating that the execution may continue on a different context.

It's generally recommended using ConfigureAwait(false) wherever possible as it can offer minor performance gain and help prevent deadlocks.

******

What is the difference between Task and ValueTask?

The main difference is that Task is a class while ValueTask is a struct. Latter was added to the BCL to alleviate unnecessary pressure on the garbage collector caused by asynchronous methods that often return synchronously (e.g. cached result). You can think of ValueTask as a discriminated union of Task or a synchronous result. Since recently, ValueTask can also represent a result signaled by ValueTaskSource.

*****

What are the main downsides of using asynchronous methods compared to synchronous methods?

Asynchronous methods can be harder to debug, especially because exceptions thrown from asynchronous methods have difficult to read stack traces. Also, running many asynchronous tasks in a tight loop can put pressure on the garbage collector.

******

What is the difference between Concurrency and Parallelism? Are they same as async programming?

The terms concurrency and parallelism are often used in relation to multithreaded programs. Concurrency and parallelism are two confusing concepts. Although they appear to be the same, concurrency, parallelism, and multithreading are not the same thing.

A Concurrency refers to how a single CPU can make progress on multiple tasks seemingly at the same time, Parallelism, on the other hand, is related to how an application can parallelize the execution of a single task - typically by splitting the task up into subtasks which can be completed in parallel.

Concurrency:

In Concurrency, multiple different threads are doing different things at the same time. So concurrency means doing multiple things at the same time but it does not specifically refer to the use of multiple threads. In concurrency when you execute multiple tasks on the single-core and the core switches context (time slicing) between tasks and serves them.

Concurrent collections in .NET are contained inside the System.Collections.Concurrent namespace and provide lock-free and thread-safe implementations of the collection classes. The ConcurrentDictionary class is contained inside the System.Collections.Concurrent namespace and represents a thread-safe dictionary.

Parallelism:

Parallelism means you execute multiple tasks on multiple cores parallelly. Parallel execution is when a computer has more than one CPU or CPU core and makes progress on more than one task simultaneously.

Parallelism is a subset of concurrency and concurrency enables parallelism. So Concurrency is a broader term and Parallelism is a subset of it. 

Concurrency is about Design while Parallelism is about Hardware. In order to achieve concurrency, we need to compose our application logic independently. So Parallelism broadly means achieving concurrency by distributing work across multiple CPUs. 

Parallel.For, Parallel.ForEach and Parallel.Invoke is available in the TPL for parallel programming in C#.

Concurrency and Parallelism: Both Concurrency and Parallelism can be used together in different combinations:

1. Concurrent but Not Parallel:  An application can be concurrent, but not parallel. This means that it makes progress on more than one task seemingly at the same time (concurrently), but the application makes context switches between making progress on each of the tasks until the tasks are completed.

2. Parallel but Not Concurrent: An application can also be parallel but not concurrent. This means that the application only works on a single task at a time, and this task is broken down into subtasks that can be processed in parallel if multiple cores are available. 

3. Neither Concurrent Nor Parallel: An application can also be neither concurrent nor parallel. This means that it works on only one task at a time, and the task is never broken down into subtasks for parallel execution. 

4. Concurrent and Parallel: Finally, an application can also be both concurrent and parallel at the same time. In simple parallel concurrent execution where an application starts up multiple threads which are then executed on multiple CPUs. It is also possible that the application works on multiple tasks concurrently, and it also breaks each task down into subtasks for parallel execution.

Async and Await:

Async programming gets mixed up with the other two i.e Concurrency and Parallelism likely because it has something to do with threads. Async describes how individual threads are used.

If you use the term "concurrency" in multithreading then it's not related to async/await at all. If concurrency means doing multiple things simultaneously then async/await supports concurrency by allowing a single thread to start one process and then do something else instead of waiting for the first process to finish.

C# has a language-level asynchronous programming model, which allows for easily writing asynchronous code. The core of async programming is the Task and Task<T> objects, which model asynchronous operations. They are supported by the async and await keywords. 

The await keyword is where the magic happens. It yields control to the caller of the method that performed await, and it ultimately allows a UI to be responsive or service to be elastic. 

Example:

Consider two tasks, T1 and T2, that have to be executed by an application. 

These two tasks are in concurrent execution if one is in an execution state while the other is waiting for its turn. As a result, one of the tasks completes ahead of the other. 
On the other hand, the two tasks are in parallel execution if both execute simultaneously. To achieve task parallelism, the program must run on a CPU with multiple cores.

In the synchronous method, if a method Foo() takes 20 seconds to complete then the thread used to call that method will do nothing for 20 seconds except wait. 

But if we execute the same method in an asynchronous method, that thread can do other things for 20 seconds. When the command is finished executing, that thread will pick up where the first thread left off. For that we use await keyword before that method call i.e await Foo().

*******

Features of  Async Programming:

Async code can be used for both I/O-bound and CPU-bound code, but differently for each scenario.
Async code uses Task<T> and Task, which are constructs used to model work being done in the background.
The async keyword turns a method into an async method, which allows you to use the await keyword in its body.
All the async methods need to have an await keyword in their body or they will never yield. However, if await is not used in the body of an async method, the C# compiler generates a warning, but the code compiles and runs as if it were a normal method.
When the await keyword is applied, it suspends the calling method and yields control back to its caller until the awaited task is complete. But await can only be used inside an async method.
An async void should only be used for event handlers because events do not have return types.

*******

What is a Task in C#? What is the difference between task and thread?

A task in C# is used to implement Task-based Asynchronous Programming and was introduced with the .NET Framework 4. Tasks in C# are basically used to make your application more responsive. 

The Task object is typically executed asynchronously on a thread pool rather than synchronously on the main thread of the application. A task scheduler is responsible for starting the Task and also responsible for managing it. By default, the Task scheduler uses threads from the thread pool to execute the Task.

The .NET framework provides Threading.Tasks class to let you create tasks and run them asynchronously. A task is an object that represents some work that should be done. The task can tell you if the work is completed and if the operation returns a result, the task gives you a result. A task can be used whenever you want to execute something in parallel. Asynchronous implementation is easy in a task, using’ async’ and ‘await’ keywords.


The Task class represents a single operation that does not return a value and that usually executes asynchronously. Task objects are one of the central components of the task-based asynchronous pattern first introduced in the .NET Framework 4. 

A task that does not return a value is represented by the System.Threading.Tasks.Task class. A task that returns a value is represented by the System.Threading.Tasks.Task<TResult> class, which inherits from Task.

Because the work performed by a Task object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the Status property, as well as the IsCanceled, IsCompleted, and IsFaulted properties, to determine the state of a task. Most commonly, a lambda expression is used to specify the work that the task is to perform.

A Thread Pool in C# is a collection of threads that can be used to perform a number of tasks in the background. Once a thread completes its task, then again it is sent to the thread pool, so that it can be reused. This reusability of threads avoids an application to create a number of threads which ultimately uses less memory consumption.

The Task Parallel Library (TPL) is based on the concept of a task, which represents an asynchronous operation. In some ways, a task resembles a thread or ThreadPool work item, but at a higher level of abstraction.  In general, the Task class will always represent a single operation and that operation will be executed asynchronously on a thread pool thread rather than synchronously on the main thread of the application.

Task taskA = new Task(PrintMessage);
taskA.Start();

Task provide more programmatic control than is possible with a thread or work item. Tasks provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.

Thread thread = new Thread(new ThreadStart(PrintMessage));  
thread.Start(); 


Task vs Thread:

1. The Thread class is used for creating and manipulating a thread while a Task represents some asynchronous operation and is part of the TPL, a set of APIs for running tasks asynchronously and in parallel.
2. The task can return a result but there is no direct mechanism to return the result from a thread. We need to use a callback delegate in the thread to get the result from a thread.
3. Task supports cancellation through the use of cancellation tokens. But Thread doesn't.
4. A task can have multiple processes happening at the same time. Threads can only have one task running at a time.
5. We can easily implement Asynchronous programming using ’async’ and ‘await’ keywords. While we need to create, run and manage thread explicitly.
6. A new Thread() is not dealing with Thread pool thread, whereas Task does use thread pool thread.
7. A Task is a higher-level concept than Thread. So the task is at a higher level of abstraction.

*******

What is synchronization and why it is important?

Synchronization in C# is a mechanism that makes sure only one process or thread accesses the critical section of the program. All the other threads have to wait until the critical section is free before they can enter it. 

Synchronization is a technique that allows only one thread to access the resource for a particular time. No other thread can interrupt until the assigned thread finishes its task.

In a multithreading program, threads are allowed to access any resource for the required execution time. Threads share resources and execute asynchronously. Accessing shared resources (data) is a critical task that sometimes may halt the system even causing deadlock sometimes. 

Why Synchronization?

Thread Synchronization deals with Deadlock, Starvation, Priority Inversion, and Busy Waiting.
Synchronization is used for achieving mutual exclusion i.e. only one process or thread accesses the critical section of the program.
Synchronization makes sure that no thread or process has an infinite waiting time.
In Synchronization, all the requests are granted in a specific order using synchronization.
Synchronization can be used for resource allocation as well. It makes sure that only one process or thread can use a resource at a time.
It may cause deadlock if synchronization does not handle properly.

Different Methods to manage Synchronization:

The .NET Framework provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction. There are multiple ways to manage synchronization in the .Net which can be divided into 4 categories:

Blocking Methods (Join, Sleep, Task.Wait)
Locking Constructs (Lock, Mutex)
Non-Blocking Synchronization
Signaling

********

What is the difference between Join and Lock synchronization?

Using Synchronization, you can synchronize access to resources in multithreaded applications. Both Join and Lock are thread synchronization mechanisms in C#.

Join: 

Join is a blocking method of synchronization. In thread synchronization, join is a blocking mechanism that pauses the calling thread. This is done till the thread whose join method was called has completed its execution.

It is similar to Sleep but it does not pause all threads. It pauses the calling thread until the thread whose join method is called has been completed. 

Thread t1 = new Thread(Func1);    
t1.Start();    
Thread t2 = new Thread(Func2);    
t2.Start();    
t1.Join();    
t2.Join(); 

Lock: 

Locking is also a synchronization mechanism. It limits the access to a resource in multiple threads. An exclusive locking mechanism is used for it. There are two main Locking mechanisms:
Lock
Mutex

The lock is a synchronization method that is used to lock in the current thread so that no other thread can interrupt the execution of the locked thread. After the thread execution is complete, it is unlocked.

It locks the critical section of code so that only one thread can execute the critical section of code at a time. If another thread tries to enter into a critical section of code then it is prevented and blocked and then it will wait until the object is released from the using thread.

public void Display()  
{ 
	lock (this)  
	{ 
		for (int i = 1; i <= 5; i++)  
		{ 
			Thread.Sleep(100);  
			Console.WriteLine("i = {0}", i);  
		} 
	} 
} 

Mutex:

Mutex stands for Mutual Exclusion. The Mutex type ensures blocks of code are executed only once at a time. It is basically used in a situation where resources have to be shared by multiple threads simultaneously.  The System.Threading.Mutex class grants exclusive access to a shared resource. 

