Xamarin is an open-source platform for building modern and performant applications for iOS, Android, and Windows with .NET. Xamarin is an abstraction layer that manages communication of shared code with underlying platform code. Xamarin runs in a managed environment that provides conveniences such as memory allocation and garbage collection.

Xamarin enables developers to share an average of 90% of their application across platforms. This pattern allows developers to write all of their business logic in a single language (or reuse existing application code) but achieve native performance, look, and feel on each platform.

Xamarin applications can be written on PC or Mac and compile into native application packages, such as an .apk file on Android, or an .ipa file on iOS.

Xamarin is for developers with the following goals:
1. Share code, test and business logic across platforms.
2. Write cross-platform applications in C# with Visual Studio.

Features:
1. Complete binding for the underlying SDKs: 
2. Objective-C, Java, C, and C++ Interop
3. Modern language constructs
4. Robust Base Class Library (BCL)
5. Modern Integrated Development Environment (IDE) â€“
6. Mobile cross-platform support

Xamarin.Android applications compile from C# into Intermediate Language (IL) which is then Just-in-Time (JIT) compiled to a native assembly when the application launches. Xamarin.Android applications run within the Mono execution environment, side by side with the Android Runtime (ART) virtual machine. Xamarin provides .NET bindings to the Android.* and Java.* namespaces. The Mono execution environment calls into these namespaces via Managed Callable Wrappers (MCW) and provides Android Callable Wrappers (ACW) to the ART, allowing both environments to invoke code in each other.

Xamarin.Android applications run inside a Mono execution environment alongside with the Android runtime Virtual Machine and explains such key concepts as Android Callable Wrappers and Managed Callable Wrappers.

Architecture:
https://learn.microsoft.com/en-us/xamarin/android/internals/architecture

API Design:
Base Class Libraries that are part of Mono, Xamarin.Android ships with bindings for various Android APIs to allow developers to create native Android applications with Mono.

At the core of Xamarin.Android there is an interop engine that bridges the C# world with the Java world and provides developers with access to the Java APIs from C# or other .NET languages.


Runnables
Java utilizes the java.lang.Runnable interface to provide a delegation mechanism. The java.lang.Thread class is a notable consumer of this interface. Android has employed the interface in the API as well. Activity.runOnUiThread() and View.post() are notable examples.

*****************************************************************************

Android Callable Wrappers and Managed Callable Wrappers are both mechanisms for integrating Java and .NET code in Android applications.

Android Callable Wrappers (ACW) are generated automatically by Xamarin.Android for Java classes and objects, and allow Java objects to be used from C# code. ACW objects implement the Java interfaces and delegate method calls to the corresponding Java objects. ACW are used in Xamarin.Android applications to access Java libraries and services.

Android callable wrappers are a JNI bridge which are used any time the Android runtime needs to invoke managed code. Android callable wrappers are how virtual methods can be overridden and Java interfaces can be implemented.

Managed Callable Wrappers (MCW) are used in Android applications that embed .NET code, such as Xamarin.Android and Unity. MCW are generated by the Mono runtime and provide a bridge between the Java and .NET environments. MCW objects are .NET objects that represent Java objects and are used to access Java objects and methods from .NET code.

Managed callable wrappers are a JNI bridge which are used any time managed code needs to invoke Android code and provide support for overriding virtual methods and implementing Java interfaces. The entire Android.* and related namespaces are managed callable wrappers generated via .jar binding. Managed callable wrappers are responsible for converting between managed and Android types and invoking the underlying Android platform methods via JNI.

Both ACW and MCW provide a way to interoperate between Java and .NET code, but they differ in the direction of the integration. ACW allows Java objects to be used from .NET code, while MCW allows .NET objects to be used from Java code.

*****************************************************************************
Garbage collection 

Cross-VM Object Collections
There are three categories of object types.

Managed objects: types which do not inherit from Java.Lang.Object , e.g. System.String. These are collected normally by the GC.

Java objects: Java types which are present within the Android runtime VM but not exposed to the Mono VM. These are boring, and won't be discussed further. These are collected normally by the Android runtime VM.

Peer objects: types which implement IJavaObject , e.g. all Java.Lang.Object and Java.Lang.Throwable subclasses. Instances of these types have two "halfs" a managed peer and a native peer. The managed peer is an instance of the C# class. The native peer is an instance of a Java class within the Android runtime VM, and the C# IJavaObject.Handle property contains a JNI global reference to the native peer.

There are two types of native peers:

Framework peers : "Normal" Java types which know nothing of Xamarin.Android, e.g. android.content.Context.

User peers : Android Callable Wrappers which are generated at build time for each Java.Lang.Object subclass present within the application.

As there are two VMs within a Xamarin.Android process, there are two types of garbage collections:

1. Android runtime collections
2. Mono collections

Managed objects are collected normally. Peer objects are collected by performing the following process:

1. All Peer objects eligible for Mono collection have their JNI global reference replaced with a JNI weak global reference.

2.An Android runtime VM GC is invoked. Any Native peer instance may be collected.

3. The JNI weak global references created in (1) are checked. If the weak reference has been collected, then the Peer object is collected. If the weak reference has not been collected, then the weak reference is replaced with a JNI global reference and the Peer object is not collected. Note: on API 14+, this means that the value returned from IJavaObject.Handle may change after a GC.


*****************************************************************************
Limitations
1. Limited Dynamic Language Support
2. Limited Java Generation Support
3. Missing constructors
4. Generic C# classes

*****************************************************************************


.NET Standard Libraries
In addition to the iOS, Android, and Mac bindings, Xamarin projects can consume .NET Standard libraries.

Portable Class Libraries
Xamarin projects can also consume .NET Portable Class Libraries, although this technology is being deprecated in favor of .NET Standard.

.NET Standard Libraries and Portable Class Libraries (PCLs) are both mechanisms for building libraries that can be used across multiple .NET platforms, such as .NET Framework, .NET Core, and Xamarin.

The main difference between the two is that .NET Standard Libraries are a newer and more flexible way of building cross-platform libraries, while PCLs are an older and more limited way of achieving the same goal.

.NET Standard Libraries provide a set of common APIs that are guaranteed to be available on any platform that implements the .NET Standard. This means that if you build a library targeting the .NET Standard, it can be used by any .NET platform that supports that version of the standard. .NET Standard Libraries offer a more granular set of APIs than PCLs, and they support a wider range of platforms.

On the other hand, PCLs provide a more limited set of APIs that are guaranteed to be available on a specific set of platforms. PCLs were originally introduced to bridge the gap between the different versions of .NET, but they have since been superseded by .NET Standard Libraries.

Overall, if you are starting a new project or building a new library, it is recommended to use .NET Standard Libraries rather than PCLs, as they offer a more flexible and future-proof way of building cross-platform libraries. However, if you are working with legacy code that uses PCLs, you may need to continue using them until you are able to update to .NET Standard Libraries.

*****************************************************************************

Interop engine is a software component that allows different programming languages or platforms to communicate and interoperate with each other. It provides a bridge between different runtime environments and enables programs written in one language or platform to call code written in another language or platform.

In the context of the .NET Framework, the interop engine is a set of runtime components that enable managed code to interoperate with unmanaged code. The interop engine provides a way to call unmanaged code, such as DLLs, COM objects, and Win32 APIs, from managed code written in C#, Visual Basic, or other .NET languages.

The interop engine provides several features, including:

Marshaling: The interop engine provides automatic data conversion between managed and unmanaged code. This is known as marshaling, and it ensures that data is properly formatted and passed between the two environments.

Type conversion: The interop engine provides automatic conversion of data types between managed and unmanaged code. This allows code written in different languages to pass data types between each other.

Exception handling: The interop engine provides a way to handle exceptions that occur during interop operations. This allows for robust error handling and recovery.

Memory management: The interop engine manages memory allocation and deallocation between managed and unmanaged code. This ensures that memory is properly allocated and released, preventing memory leaks and other issues.

Overall, the interop engine is a critical component of the .NET Framework and is essential for enabling interoperability between managed and unmanaged code. It allows developers to integrate existing code and technologies into their .NET applications, making it easier to leverage existing investments and infrastructure.



*****************************************************************************
Intermediate Language (IL) is a low-level, platform-agnostic bytecode language that is used by the .NET Framework as the output of the C# compiler. The IL code is generated by the C# compiler from the source code, and then executed by the Common Language Runtime (CLR) at runtime.

IL is a stack-based language, meaning that all operations are performed on a stack. Each method in the IL code has its own local variable stack frame, which is used to store method arguments and local variables. The IL code is compiled into machine code by the JIT (Just-In-Time) compiler at runtime, and executed directly on the processor.

The use of IL provides several benefits for C# developers. First, IL is a standardized bytecode language that is platform-agnostic, meaning that it can be executed on any platform that supports the .NET Framework. This allows C# developers to write code that can run on multiple platforms without having to worry about platform-specific details.

Second, IL is a very efficient language that can be optimized by the JIT compiler at runtime. This allows C# applications to achieve high performance, even on complex tasks.

Finally, IL provides a way to obfuscate C# code, making it harder for attackers to reverse-engineer and steal the code. This is because the IL code is very different from the original C# code and can be very difficult to understand without the original source code.

Overall, Intermediate Language is a critical component of the .NET Framework and is essential to the execution of C# code.

*****************************************************************************

Just-In-Time (JIT) is a compiler used in the .NET Framework to convert Intermediate Language (IL) code into machine code that can be executed by the processor. The JIT compiler is part of the Common Language Runtime (CLR) and is responsible for compiling IL code into native machine code on demand, at runtime.

When a .NET application is launched, the CLR loads the IL code into memory and uses the JIT compiler to compile the IL code into machine code. This is done on an as-needed basis, as the application runs and each method is called for the first time. Once the JIT compiler has compiled a method, the compiled code is stored in memory for subsequent calls, improving performance for subsequent method calls.

The JIT compiler performs several optimization techniques to improve performance, such as inlining method calls, eliminating dead code, and using CPU-specific optimizations. These optimizations help to make the compiled code more efficient and faster than the original IL code.

One of the advantages of using a JIT compiler is that it provides platform independence. Since the IL code is platform-agnostic, it can be compiled into machine code that is specific to the processor and operating system on which the application is running. This allows .NET applications to run on any platform that supports the CLR.

Overall, JIT compilation is a critical component of the .NET Framework and is essential to the execution of .NET applications. It provides high performance and platform independence, making it a popular choice for developing cross-platform applications.

*****************************************************************************

The Mono execution environment is a cross-platform, open-source implementation of the .NET Framework. It provides a runtime environment for executing .NET applications on a wide range of platforms, including Linux, macOS, and Windows.

The Mono execution environment includes several key components, including:

Mono Runtime: The Mono runtime is the core component of the Mono execution environment. It includes a Just-In-Time (JIT) compiler, a garbage collector, and other runtime components needed to execute .NET applications.

Class Libraries: The Mono execution environment includes a set of class libraries that implement the .NET Framework Base Class Library (BCL) and other additional libraries. These libraries provide a wide range of functionality, including support for networking, input/output (I/O), and user interfaces.

Development Tools: The Mono execution environment includes a set of development tools, such as compilers, debuggers, and profiling tools. These tools are designed to help developers create, debug, and optimize .NET applications.

Interoperability Features: The Mono execution environment includes support for interoperability with other programming languages and platforms. It provides a way to call into native code, such as C or C++, and supports a wide range of standards and protocols for communication with other systems.

*****************************************************************************
Android Runtime:
Android Runtime is an application runtime environment used by the Android operating system. Replacing Dalvik, the process virtual machine originally used by Android, ART performs the translation of the application's bytecode into native instructions that are later executed by the device's runtime environment.

*****************************************************************************